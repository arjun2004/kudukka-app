"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_gas_estimate-l1-fee_js"],{

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: function() { return /* binding */ createCurve; },\n/* harmony export */   getHash: function() { return /* binding */ getHash; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: function(key) {\n            for(var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                msgs[_key - 1] = arguments[_key];\n            }\n            return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs));\n        },\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return Object.freeze({\n        ...create(defHash),\n        create\n    });\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQzFCO0FBQ3FCO0FBQ1A7QUFDeEQsd0NBQXdDO0FBQ2pDLFNBQVNJLFFBQVFDLElBQUk7SUFDeEIsT0FBTztRQUNIQTtRQUNBTCxNQUFNLFNBQUNNOzZDQUFRQztnQkFBQUE7O21CQUFTUCx3REFBSUEsQ0FBQ0ssTUFBTUMsS0FBS0wsZ0VBQVdBLElBQUlNOztRQUN2REwsV0FBV0EsOERBQUFBO0lBQ2Y7QUFDSjtBQUNPLFNBQVNNLFlBQVlDLFFBQVEsRUFBRUMsT0FBTztJQUN6QyxNQUFNQyxTQUFTLENBQUNOLE9BQVNGLHFFQUFXQSxDQUFDO1lBQUUsR0FBR00sUUFBUTtZQUFFLEdBQUdMLFFBQVFDLEtBQUs7UUFBQztJQUNyRSxPQUFPTyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFHRixPQUFPRCxRQUFRO1FBQUVDO0lBQU87QUFDdEQsRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/ZjI0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImhtYWMiLCJjb25jYXRCeXRlcyIsInJhbmRvbUJ5dGVzIiwid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImtleSIsIm1zZ3MiLCJjcmVhdGVDdXJ2ZSIsImN1cnZlRGVmIiwiZGVmSGFzaCIsImNyZWF0ZSIsIk9iamVjdCIsImZyZWV6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: function() { return /* binding */ pippenger; },\n/* harmony export */   precomputeMSMUnsafe: function() { return /* binding */ precomputeMSMUnsafe; },\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return {\n        windows,\n        windowSize\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes (elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n) {\n            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : c.ZERO;\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                } else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */ wNAFUnsafe (W, precomputes, n) {\n            let acc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : c.ZERO;\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for(let window = 0; window < windows; window++){\n                const offset = window * windowSize;\n                if (n === _0n) break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0) continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0) curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes (W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached (P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe (P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize (P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        }\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length) throw new Error(\"arrays of points and scalars must have equal length\");\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < scalars.length; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsMEJBQTBCO0FBQzRCO0FBQ0Y7QUFDcEQsTUFBTUksTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLFNBQVNFLGdCQUFnQkMsU0FBUyxFQUFFQyxJQUFJO0lBQ3BDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07SUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7QUFDN0I7QUFDQSxTQUFTRyxVQUFVQyxDQUFDLEVBQUVDLElBQUk7SUFDdEIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNILE1BQU1BLEtBQUssS0FBS0EsSUFBSUMsTUFDMUMsTUFBTSxJQUFJRyxNQUFNLHVDQUF1Q0gsT0FBTyxjQUFjRDtBQUNwRjtBQUNBLFNBQVNLLFVBQVVMLENBQUMsRUFBRUMsSUFBSTtJQUN0QkYsVUFBVUMsR0FBR0M7SUFDYixNQUFNSyxVQUFVQyxLQUFLQyxJQUFJLENBQUNQLE9BQU9ELEtBQUssR0FBRyxjQUFjO0lBQ3ZELE1BQU1TLGFBQWEsS0FBTVQsQ0FBQUEsSUFBSSxJQUFJLDBCQUEwQjtJQUMzRCxPQUFPO1FBQUVNO1FBQVNHO0lBQVc7QUFDakM7QUFDQSxTQUFTQyxrQkFBa0JDLE1BQU0sRUFBRUMsQ0FBQztJQUNoQyxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0gsU0FDZixNQUFNLElBQUlQLE1BQU07SUFDcEJPLE9BQU9JLE9BQU8sQ0FBQyxDQUFDQyxHQUFHQztRQUNmLElBQUksQ0FBRUQsQ0FBQUEsYUFBYUosQ0FBQUEsR0FDZixNQUFNLElBQUlSLE1BQU0sNEJBQTRCYTtJQUNwRDtBQUNKO0FBQ0EsU0FBU0MsbUJBQW1CQyxPQUFPLEVBQUVDLEtBQUs7SUFDdEMsSUFBSSxDQUFDUCxNQUFNQyxPQUFPLENBQUNLLFVBQ2YsTUFBTSxJQUFJZixN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RztRQUNIMEQsR0FBRztRQUNIQyxJQUFJO1FBQ0pDLElBQUk7SUFDUixHQUFHO1FBQ0NDLFlBQVk7UUFDWkMsYUFBYTtJQUNqQjtJQUNBLGVBQWU7SUFDZixPQUFPQyxPQUFPQyxNQUFNLENBQUM7UUFDakIsR0FBRzdHLG9EQUFPQSxDQUFDcUcsTUFBTXhELENBQUMsRUFBRXdELE1BQU1LLFVBQVUsQ0FBQztRQUNyQyxHQUFHTCxLQUFLO1FBQ1IsR0FBRztZQUFFekUsR0FBR3lFLE1BQU1DLEVBQUUsQ0FBQ1EsS0FBSztRQUFDLENBQUM7SUFDNUI7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/NjFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCwgYml0TGVuIH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiBjb25zdFRpbWVOZWdhdGUoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLicgKyBiaXRzICsgJ10sIGdvdCBXPScgKyBXKTtcbn1cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBiaXRzKSB7XG4gICAgdmFsaWRhdGVXKFcsIGJpdHMpO1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlc1xuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwb2ludFdpbmRvd1NpemVzID0gbmV3IFdlYWtNYXAoKTsgLy8gVGhpcyBhbGxvd3MgdXNlIG1ha2UgcG9pbnRzIGltbXV0YWJsZSAobm90aGluZyBjaGFuZ2VzIGluc2lkZSlcbmZ1bmN0aW9uIGdldFcoUCkge1xuICAgIHJldHVybiBwb2ludFdpbmRvd1NpemVzLmdldChQKSB8fCAxO1xufVxuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICBoYXNQcmVjb21wdXRlcyhlbG0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuLCBwID0gYy5aRVJPKSB7XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEBwYXJhbSBlbG0gUG9pbnQgaW5zdGFuY2VcbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcGFyYW0gYWNjIGFjY3VtdWxhdG9yIHBvaW50IHRvIGFkZCByZXN1bHQgb2YgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQHJldHVybnMgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIHdOQUZVbnNhZmUoVywgcHJlY29tcHV0ZXMsIG4sIGFjYyA9IGMuWkVSTykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gbmVlZCB0byBnbyBvdmVyIGVtcHR5IHNjYWxhclxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgY3VyciA9IHByZWNvbXB1dGVzW29mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDFdOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA8IDApXG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGJ5IHJlLXVzaW5nIGFjYywgd2UgY2FuIHNhdmUgYSBsb3Qgb2YgYWRkaXRpb25zIGluIGNhc2Ugb2YgTVNNXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZChjdXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgVyA9IGdldFcoUCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWRVbnNhZmUoUCwgbiwgdHJhbnNmb3JtLCBwcmV2KSB7XG4gICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcbiAgICAgICAgICAgIGlmIChXID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2FmZUxhZGRlcihQLCBuLCBwcmV2KTsgLy8gRm9yIFc9MSBsYWRkZXIgaXMgfngyIGZhc3RlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRlVuc2FmZShXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4sIHByZXYpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gICAgICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgICAgICBzZXRXaW5kb3dTaXplKFAsIFcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcbiAgICAgICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUoUCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGlwcGVuZ2VyIGFsZ29yaXRobSBmb3IgbXVsdGktc2NhbGFyIG11bHRpcGxpY2F0aW9uIChNU00sIFBhICsgUWIgKyBSYyArIC4uLikuXG4gKiAzMHggZmFzdGVyIHZzIG5haXZlIGFkZGl0aW9uIG9uIEw9NDA5NiwgMTB4IGZhc3RlciB3aXRoIHByZWNvbXB1dGVzLlxuICogRm9yIE49MjU0Yml0LCBMPTEsIGl0IGRvZXM6IDEwMjQgQUREICsgMjU0IERCTC4gRm9yIEw9NTogMTUzNiBBREQgKyAyNTQgREJMLlxuICogQWxnb3JpdGhtaWNhbGx5IGNvbnN0YW50LXRpbWUgKGZvciBzYW1lIEwpLCBldmVuIHdoZW4gMSBwb2ludCArIHNjYWxhciwgb3Igd2hlbiBzY2FsYXIgPSAwLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcGFyYW0gc2NhbGFycyBhcnJheSBvZiBMIHNjYWxhcnMgKGFrYSBwcml2YXRlIGtleXMgLyBiaWdpbnRzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlwcGVuZ2VyKGMsIGZpZWxkTiwgcG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgLy8gSWYgd2Ugc3BsaXQgc2NhbGFycyBieSBzb21lIHdpbmRvdyAobGV0J3Mgc2F5IDggYml0cyksIGV2ZXJ5IGNodW5rIHdpbGwgb25seVxuICAgIC8vIHRha2UgMjU2IGJ1Y2tldHMgZXZlbiBpZiB0aGVyZSBhcmUgNDA5NiBzY2FsYXJzLCBhbHNvIHJlLXVzZXMgZG91YmxlLlxuICAgIC8vIFRPRE86XG4gICAgLy8gLSBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDI0Lzc1MC5wZGZcbiAgICAvLyAtIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy8xMDI4N1xuICAgIC8vIDAgaXMgYWNjZXB0ZWQgaW4gc2NhbGFyc1xuICAgIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggIT09IHNjYWxhcnMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5cyBvZiBwb2ludHMgYW5kIHNjYWxhcnMgbXVzdCBoYXZlIGVxdWFsIGxlbmd0aCcpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBvaW50cy5sZW5ndGgpKTtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gd2JpdHMgPiAxMiA/IHdiaXRzIC0gMyA6IHdiaXRzID4gNCA/IHdiaXRzIC0gMiA6IHdiaXRzID8gMiA6IDE7IC8vIGluIGJpdHNcbiAgICBjb25zdCBNQVNLID0gKDEgPDwgd2luZG93U2l6ZSkgLSAxO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTUFTSyArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKHplcm8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxhciA9IHNjYWxhcnNbal07XG4gICAgICAgICAgICBjb25zdCB3Yml0cyA9IE51bWJlcigoc2NhbGFyID4+IEJpZ0ludChpKSkgJiBCaWdJbnQoTUFTSykpO1xuICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzSSA9IHplcm87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXB1dGVNU01VbnNhZmUoYywgZmllbGROLCBwb2ludHMsIHdpbmRvd1NpemUpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBBbmFseXNpcyBvZiBXaW5kb3ctYmFzZWQgUHJlY29tcHV0YXRpb25cbiAgICAgKlxuICAgICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG4gICAgICogLSBTdGFuZGFyZCBwcmVjb21wdXRhdGlvbiByZXF1aXJlczpcbiAgICAgKiAgIC0gMzEgYWRkaXRpb25zIHBlciBzY2FsYXIgw5cgMjU2IHNjYWxhcnMgPSA3LDkzNiBvcHNcbiAgICAgKiAgIC0gUGx1cyAyNTUgc3VtbWFyeSBhZGRpdGlvbnMgPSA4LDE5MSB0b3RhbCBvcHNcbiAgICAgKiAgIE5vdGU6IFN1bW1hcnkgYWRkaXRpb25zIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGFjY3VtdWxhdG9yXG4gICAgICpcbiAgICAgKiBDaHVua2VkIFByZWNvbXB1dGF0aW9uIEFuYWx5c2lzOlxuICAgICAqIC0gVXNpbmcgMzIgY2h1bmtzIHJlcXVpcmVzOlxuICAgICAqICAgLSAyNTUgYWRkaXRpb25zIHBlciBjaHVua1xuICAgICAqICAgLSAyNTYgZG91YmxpbmdzXG4gICAgICogICAtIFRvdGFsOiAoMjU1IMOXIDMyKSArIDI1NiA9IDgsNDE2IG9wc1xuICAgICAqXG4gICAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG4gICAgICogV2luZG93IFNpemUgfCBTdGFuZGFyZCBQb2ludHMgfCBDaHVua2VkIFBvaW50c1xuICAgICAqIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcbiAgICAgKiAgICAgOC1iaXQgICB8ICAgIDQsMjI0ICAgICAgICB8ICAgICAyNTVcbiAgICAgKiAgICAxMC1iaXQgICB8ICAgMTMsODI0ICAgICAgICB8ICAgMSwwMjNcbiAgICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcbiAgICAgKlxuICAgICAqIEtleSBBZHZhbnRhZ2VzOlxuICAgICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiAyLiBNb3JlIGVmZmljaWVudCBmb3Igc21hbGxlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgIC0gMTYgY2h1bmtzOiAoMTYgw5cgMjU1KSArIDI1NiA9IDQsMzM2IG9wc1xuICAgICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuICAgICAqXG4gICAgICogTGltaXRhdGlvbnM6XG4gICAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuICAgICAqIC0gUGVyZm9ybWFuY2UgZGVncmFkZXMgd2l0aCBsYXJnZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgIC0gT3B0aW1hbCBmb3IgfjI1NiBzY2FsYXJzXG4gICAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuICAgICAqL1xuICAgIHZhbGlkYXRlVyh3aW5kb3dTaXplLCBmaWVsZE4uQklUUyk7XG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IDIgKiogd2luZG93U2l6ZSAtIDE7IC8vIHRhYmxlIHNpemUgKHdpdGhvdXQgemVybylcbiAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cbiAgICBjb25zdCBNQVNLID0gQmlnSW50KCgxIDw8IHdpbmRvd1NpemUpIC0gMSk7XG4gICAgY29uc3QgdGFibGVzID0gcG9pbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGFjYyA9IHA7IGkgPCB0YWJsZVNpemU7IGkrKykge1xuICAgICAgICAgICAgcmVzLnB1c2goYWNjKTtcbiAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICByZXR1cm4gKHNjYWxhcnMpID0+IHtcbiAgICAgICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgICAgIGlmIChzY2FsYXJzLmxlbmd0aCA+IHBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IG9mIHNjYWxhcnMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gYXJyYXkgb2YgcG9pbnRzJyk7XG4gICAgICAgIGxldCByZXMgPSB6ZXJvO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGRvdWJsZSBpZiBhY2N1bXVsYXRvciBpcyBzdGlsbCB6ZXJvLlxuICAgICAgICAgICAgaWYgKHJlcyAhPT0gemVybylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmRvdWJsZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChjaHVua3MgKiB3aW5kb3dTaXplIC0gKGkgKyAxKSAqIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzY2FsYXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IHNjYWxhcnNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyciA9IE51bWJlcigobiA+PiBzaGlmdEJ5KSAmIE1BU0spO1xuICAgICAgICAgICAgICAgIGlmICghY3VycilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgemVybyBzY2FsYXJzIGNodW5rc1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQodGFibGVzW2pdW2N1cnIgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsidmFsaWRhdGVGaWVsZCIsIm5MZW5ndGgiLCJ2YWxpZGF0ZU9iamVjdCIsImJpdExlbiIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJ2YWxpZGF0ZVciLCJXIiwiYml0cyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImNhbGNXT3B0cyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJ2YWxpZGF0ZU1TTVBvaW50cyIsInBvaW50cyIsImMiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwicCIsImkiLCJ2YWxpZGF0ZU1TTVNjYWxhcnMiLCJzY2FsYXJzIiwiZmllbGQiLCJzIiwiaXNWYWxpZCIsInBvaW50UHJlY29tcHV0ZXMiLCJXZWFrTWFwIiwicG9pbnRXaW5kb3dTaXplcyIsImdldFciLCJQIiwiZ2V0Iiwid05BRiIsImhhc1ByZWNvbXB1dGVzIiwiZWxtIiwidW5zYWZlTGFkZGVyIiwibiIsIlpFUk8iLCJkIiwiYWRkIiwiZG91YmxlIiwicHJlY29tcHV0ZVdpbmRvdyIsImJhc2UiLCJ3aW5kb3ciLCJwdXNoIiwicHJlY29tcHV0ZXMiLCJmIiwiQkFTRSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwib2Zmc2V0Iiwid2JpdHMiLCJvZmZzZXQxIiwib2Zmc2V0MiIsImFicyIsImNvbmQxIiwiY29uZDIiLCJ3TkFGVW5zYWZlIiwiYWNjIiwiY3VyciIsImdldFByZWNvbXB1dGVzIiwidHJhbnNmb3JtIiwiY29tcCIsInNldCIsIndOQUZDYWNoZWQiLCJ3TkFGQ2FjaGVkVW5zYWZlIiwicHJldiIsInNldFdpbmRvd1NpemUiLCJkZWxldGUiLCJwaXBwZW5nZXIiLCJmaWVsZE4iLCJsZW5ndGgiLCJ6ZXJvIiwiTUFTSyIsImJ1Y2tldHMiLCJmaWxsIiwibGFzdEJpdHMiLCJmbG9vciIsIkJJVFMiLCJzdW0iLCJqIiwic2NhbGFyIiwicmVzSSIsInN1bUkiLCJwcmVjb21wdXRlTVNNVW5zYWZlIiwidGFibGVTaXplIiwiY2h1bmtzIiwidGFibGVzIiwibWFwIiwicmVzIiwidmFsaWRhdGVCYXNpYyIsImN1cnZlIiwiRnAiLCJoIiwiR3giLCJHeSIsIm5CaXRMZW5ndGgiLCJuQnl0ZUxlbmd0aCIsIk9iamVjdCIsImZyZWV6ZSIsIk9SREVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...def,\n                DST: def.DST,\n                ...options\n            });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...def,\n                DST: def.encodeDST,\n                ...options\n            });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"mapToCurve: expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"mapToCurve: expected array of bigints\");\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0YsNkZBQTZGO0FBQzdGLE1BQU1NLFFBQVFKLHNEQUFlQTtBQUM3Qiw0Q0FBNEM7QUFDNUMsU0FBU0ssTUFBTUMsS0FBSyxFQUFFQyxNQUFNO0lBQ3hCQyxLQUFLRjtJQUNMRSxLQUFLRDtJQUNMLElBQUlELFFBQVEsS0FBS0EsU0FBUyxLQUFNLElBQUlDLFFBQ2hDLE1BQU0sSUFBSUUsTUFBTSwwQkFBMEJIO0lBQzlDLE1BQU1JLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFTDtJQUFPLEdBQUdNLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlQLFNBQVMsR0FBR08sS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR1IsUUFBUTtRQUNqQkEsV0FBVztJQUNmO0lBQ0EsT0FBTyxJQUFJUyxXQUFXTDtBQUMxQjtBQUNBLFNBQVNNLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixNQUFNQyxNQUFNLElBQUlKLFdBQVdFLEVBQUVWLE1BQU07SUFDbkMsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUlHLEVBQUVWLE1BQU0sRUFBRU8sSUFBSztRQUMvQkssR0FBRyxDQUFDTCxFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRSxHQUFHSSxDQUFDLENBQUNKLEVBQUU7SUFDeEI7SUFDQSxPQUFPSztBQUNYO0FBQ0EsU0FBU1gsS0FBS1ksSUFBSTtJQUNkLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixPQUN0QixNQUFNLElBQUlYLE1BQU07QUFDeEI7QUFDQSxvR0FBb0c7QUFDcEcsdURBQXVEO0FBQ2hELFNBQVNjLG1CQUFtQkMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQztJQUN0RDVCLGlEQUFN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Q3hFRyxlQUFjdkUsR0FBRyxFQUFFMEIsT0FBTztZQUN0QixNQUFNVyxJQUFJYixjQUFjeEIsS0FBSyxHQUFHO2dCQUFFLEdBQUcrRCxHQUFHO2dCQUFFOUQsS0FBSzhELElBQUlTLFNBQVM7Z0JBQUUsR0FBRzlDLE9BQU87WUFBQztZQUN6RSxNQUFNMEMsSUFBSVAsTUFBTUssVUFBVSxDQUFDSixXQUFXekIsQ0FBQyxDQUFDLEVBQUUsR0FBR2dDLGFBQWE7WUFDMURELEVBQUVFLGNBQWM7WUFDaEIsT0FBT0Y7UUFDWDtRQUNBLDBDQUEwQztRQUMxQ04sWUFBV1csT0FBTztZQUNkLElBQUksQ0FBQ3RGLE1BQU11RixPQUFPLENBQUNELFVBQ2YsTUFBTSxJQUFJeEYsTUFBTTtZQUNwQixLQUFLLE1BQU1LLEtBQUttRixRQUNaLElBQUksT0FBT25GLE1BQU0sVUFDYixNQUFNLElBQUlMLE1BQU07WUFDeEIsTUFBTW1GLElBQUlQLE1BQU1LLFVBQVUsQ0FBQ0osV0FBV1csVUFBVUosYUFBYTtZQUM3REQsRUFBRUUsY0FBYztZQUNoQixPQUFPRjtRQUNYO0lBQ0o7QUFDSixFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz8yMGQyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBhbnVtKHZhbHVlKTtcbiAgICBhbnVtKGxlbmd0aCk7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEkyT1NQIGlucHV0OiAnICsgdmFsdWUpO1xuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG1kOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cbi8vIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxuLy8gMi4gSCBNVVNUIGJlIGFuIFhPRiB0aGF0IGhhcyBiZWVuIHByb3ZlZCBpbmRpZmZlcmVudGlhYmxlIGZyb21cbi8vICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMlxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuSW5CeXRlcywgaywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjJcbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIEYgdG8gb3V0cHV0XG4gKiBAcGFyYW0gb3B0aW9ucyBge0RTVDogc3RyaW5nLCBwOiBiaWdpbnQsIG06IG51bWJlciwgazogbnVtYmVyLCBleHBhbmQ6ICd4bWQnIHwgJ3hvZicsIGhhc2g6IEh9YCwgc2VlIGFib3ZlXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XG4gICAgICAgIERTVDogJ3N0cmluZ09yVWludDhBcnJheScsXG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGs6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYW51bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdHlwZW9mIF9EU1QgPT09ICdzdHJpbmcnID8gdXRmOFRvQnl0ZXMoX0RTVCkgOiBfRFNUO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2FtZSBhcyBlbmNvZGVUb0N1cnZlLCBidXQgd2l0aG91dCBoYXNoXG4gICAgICAgIG1hcFRvQ3VydmUoc2NhbGFycykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjYWxhcnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIHNjYWxhcnMpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlOiBleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHNjYWxhcnMpKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsibW9kIiwiYWJ5dGVzIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJ1dGY4VG9CeXRlcyIsInZhbGlkYXRlT2JqZWN0Iiwib3MyaXAiLCJpMm9zcCIsInZhbHVlIiwibGVuZ3RoIiwiYW51bSIsIkVycm9yIiwicmVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsbCIsImkiLCJVaW50OEFycmF5Iiwic3RyeG9yIiwiYSIsImIiLCJhcnIiLCJpdGVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImV4cGFuZF9tZXNzYWdlX3htZCIsIm1zZyIsIkRTVCIsImxlbkluQnl0ZXMiLCJIIiwib3V0cHV0TGVuIiwiYl9pbl9ieXRlcyIsImJsb2NrTGVuIiwicl9pbl9ieXRlcyIsImVsbCIsIk1hdGgiLCJjZWlsIiwiRFNUX3ByaW1lIiwiWl9wYWQiLCJsX2lfYl9zdHIiLCJiXzAiLCJhcmdzIiwicHNldWRvX3JhbmRvbV9ieXRlcyIsInNsaWNlIiwiZXhwYW5kX21lc3NhZ2VfeG9mIiwiayIsImRrTGVuIiwiY3JlYXRlIiwidXBkYXRlIiwiZGlnZXN0IiwiaGFzaF90b19maWVsZCIsImNvdW50Iiwib3B0aW9ucyIsInAiLCJtIiwiaGFzaCIsImV4cGFuZCIsIl9EU1QiLCJsb2cycCIsInRvU3RyaW5nIiwiTCIsImxlbl9pbl9ieXRlcyIsInByYiIsInUiLCJlIiwiaiIsImVsbV9vZmZzZXQiLCJ0diIsInN1YmFycmF5IiwiaXNvZ2VueU1hcCIsImZpZWxkIiwibWFwIiwiQ09FRkYiLCJyZXZlcnNlIiwieCIsInkiLCJ4TnVtIiwieERlbiIsInlOdW0iLCJ5RGVuIiwidmFsIiwicmVkdWNlIiwiYWNjIiwiYWRkIiwibXVsIiwiZGl2IiwiY3JlYXRlSGFzaGVyIiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmIiwiaGFzaFRvQ3VydmUiLCJ1MCIsImZyb21BZmZpbmUiLCJ1MSIsIlAiLCJjbGVhckNvZmFjdG9yIiwiYXNzZXJ0VmFsaWRpdHkiLCJlbmNvZGVUb0N1cnZlIiwiZW5jb2RlRFNUIiwic2NhbGFycyIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpLegendre: function() { return /* binding */ FpLegendre; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ // TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (modulo <= _0n) throw new Error(\"invalid modulus\");\n    if (modulo === _1n) return _0n;\n    let res = _1n;\n    while(power > _0n){\n        if (power & _1n) res = res * num % modulo;\n        num = num * num % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for(Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for(Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++){\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000) throw new Error(\"Cannot find square root: likely non-prime P\");\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error(\"Cannot find square root\");\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while(!Fp.eql(b, Fp.ONE)){\n            if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for(let t2 = Fp.sqr(b); m < r; m++){\n                if (Fp.eql(t2, Fp.ONE)) break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n_c = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return f.ONE;\n    if (power === _1n) return num;\n    let p = f.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n_c1 = FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */ function FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (f.is0(num)) return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\n_c2 = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n_c3 = FpDiv;\nfunction FpLegendre(order) {\n    // (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n    // (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x)=>f.pow(x, legendreConst);\n}\n_c4 = FpLegendre;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x)=>{\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n_c5 = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * NOTE: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, redef = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c)=>c ? b : a,\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        }\n    });\n    return Object.freeze(f);\n}\n_c6 = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n_c7 = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n_c8 = FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */ function hashToPrivateScalar(hash, groupOrder) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder) {\n    let isLE = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"FpSqrt\");\n$RefreshReg$(_c1, \"FpPow\");\n$RefreshReg$(_c2, \"FpInvertBatch\");\n$RefreshReg$(_c3, \"FpDiv\");\n$RefreshReg$(_c4, \"FpLegendre\");\n$RefreshReg$(_c5, \"FpIsSquare\");\n$RefreshReg$(_c6, \"Field\");\n$RefreshReg$(_c7, \"FpSqrtOdd\");\n$RefreshReg$(_c8, \"FpSqrtEven\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDcEUsc0RBQXNEO0FBQ2lGO0FBQ3ZJLGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTSxhQUFhLEdBQUdGLE9BQU8sSUFBSUcsTUFBTSxhQUFhLEdBQUdILE9BQU87QUFDdEcsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU0sYUFBYSxHQUFHSixPQUFPLElBQUlLLE1BQU0sYUFBYSxHQUFHTCxPQUFPLElBQUlNLE1BQU0sYUFBYSxHQUFHTixPQUFPO0FBQ3JHLGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNLGFBQWEsR0FBR1AsT0FBTyxJQUFJUSxPQUFPLGFBQWEsR0FBR1IsT0FBTztBQUNyRSx3QkFBd0I7QUFDakIsU0FBU1MsSUFBSUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3BCLE1BQU1DLFNBQVNGLElBQUlDO0lBQ25CLE9BQU9DLFVBQVViLE1BQU1hLFNBQVNELElBQUlDO0FBQ3hDO0FBQ0E7Ozs7O0NBS0MsR0FDRCxvQ0FBb0M7QUFDN0IsU0FBU0MsSUFBSUMsR0FBRyxFQUFFQyxLQUFLLEVBQUVDLE1BQU07SUFDbEMsSUFBSUQsUUFBUWhCLEtBQ1IsTUFBTSxJQUFJa0IsTUFBTTtJQUNwQixJQUFJRCxVQUFVakIsS0FDVixNQUFNLElBQUlrQixNQUFNO0lBQ3BCLElBQUlELFdBQVdmLEtBQ1gsT0FBT0Y7SUFDWCxJQUFJbUIsTUFBTWpCO0lBQ1YsTUFBT2MsUUFBUWhCLElBQUs7UUFDaEIsSUFBSWdCLFFBQVFkLEtBQ1JpQixNQUFNLE1BQU9KLE1BQU9FO1FBQ3hCRixNQUFNLE1BQU9BLE1BQU9FO1FBQ3BCRCxVQUFVZDtJQUNkO0lBQ0EsT0FBT2lCO0FBQ1g7QUFDQSwwREFBMEQ7QUFDbkQs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QUMxRSxNQUFNaEksTUFBTTRGLE9BQU9qSCwwREFBZUEsQ0FBQ29KLE9BQU9uSiwwREFBZUEsQ0FBQ21KO0lBQzFELCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVdkksSUFBSUssS0FBSzJILGFBQWF4SSxPQUFPQTtJQUM3QyxPQUFPeUcsT0FBTzdHLDBEQUFlQSxDQUFDbUosU0FBU0QsWUFBWW5KLDBEQUFlQSxDQUFDb0osU0FBU0Q7QUFDaEYsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/MGNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgXzNuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KSwgXzVuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgXzhuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg5KSwgXzE2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZXhwb25lbnQsIG5lZ2F0aXZlcyB1bnN1cHBvcnRlZCcpO1xuICAgIGlmIChtb2R1bG8gPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbW9kdWx1cycpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIG5vbi16ZXJvIG51bWJlcicpO1xuICAgIGlmIChtb2R1bG8gPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgbW9kdWx1cywgZ290ICcgKyBtb2R1bG8pO1xuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKykge1xuICAgICAgICAvLyBDcmFzaCBpbnN0ZWFkIG9mIGluZmluaXR5IGxvb3AsIHdlIGNhbm5vdCByZWFzb25hYmxlIGNvdW50IHVudGlsIFAuXG4gICAgICAgIGlmIChaID4gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3Q6IGxpa2VseSBub24tcHJpbWUgUCcpO1xuICAgIH1cbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZXhwb25lbnQsIG5lZ2F0aXZlcyB1bnN1cHBvcnRlZCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcExlZ2VuZHJlKG9yZGVyKSB7XG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgbm9uIHJlc2lkdWVcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAob3JkZXIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKGYsIHgpID0+IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmUgPSBGcExlZ2VuZHJlKGYuT1JERVIpO1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gbGVnZW5kcmUoZiwgeCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBOT1RFOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91IGRvaW5nLlxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzJyk7XG4gICAgbGV0IHNxcnRQOyAvLyBjYWNoZWQgc3FydFBcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJyArIHR5cGVvZiBudW0pO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8XG4gICAgICAgICAgICAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNxcnRQKVxuICAgICAgICAgICAgICAgICAgICBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNxcnRQKGYsIG4pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIEJZVEVTICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGhhc2hMZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGxlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiYml0TWFzayIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJfOW4iLCJfMTZuIiwibW9kIiwiYSIsImIiLCJyZXN1bHQiLCJwb3ciLCJudW0iLCJwb3dlciIsIm1vZHVsbyIsIkVycm9yIiwicmVzIiwicG93MiIsIngiLCJpbnZlcnQiLCJudW1iZXIiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwidG9uZWxsaVNoYW5rcyIsIlAiLCJsZWdlbmRyZUMiLCJRIiwiUyIsIloiLCJwMWRpdjQiLCJ0b25lbGxpRmFzdCIsIkZwIiwicm9vdCIsImVxbCIsInNxciIsIlExZGl2MiIsInRvbmVsbGlTbG93IiwibmVnIiwiT05FIiwiZyIsIm11bCIsIlpFUk8iLCJ0MiIsImdlIiwiRnBTcXJ0Iiwic3FydDNtb2Q0IiwiYzEiLCJzcXJ0NW1vZDgiLCJuMiIsIm52IiwiaSIsInN1YiIsImlzTmVnYXRpdmVMRSIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJPUkRFUiIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJvcHRzIiwicmVkdWNlIiwibWFwIiwidmFsIiwiRnBQb3ciLCJmIiwicCIsImQiLCJGcEludmVydEJhdGNoIiwibnVtcyIsInRtcCIsIkFycmF5IiwibGVuZ3RoIiwibGFzdE11bHRpcGxpZWQiLCJhY2MiLCJpczAiLCJpbnZlcnRlZCIsImludiIsInJlZHVjZVJpZ2h0IiwiRnBEaXYiLCJsaHMiLCJyaHMiLCJGcExlZ2VuZHJlIiwib3JkZXIiLCJsZWdlbmRyZUNvbnN0IiwiRnBJc1NxdWFyZSIsImxlZ2VuZHJlIiwibkxlbmd0aCIsIm5CaXRMZW5ndGgiLCJfbkJpdExlbmd0aCIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwibkJ5dGVMZW5ndGgiLCJNYXRoIiwiY2VpbCIsIkZpZWxkIiwiYml0TGVuIiwiaXNMRSIsInJlZGVmIiwic3FydFAiLCJPYmplY3QiLCJmcmVlemUiLCJjcmVhdGUiLCJpc1ZhbGlkIiwiaXNPZGQiLCJhZGQiLCJkaXYiLCJzcXJOIiwiYWRkTiIsInN1Yk4iLCJtdWxOIiwic3FydCIsImludmVydEJhdGNoIiwibHN0IiwiY21vdiIsImMiLCJ0b0J5dGVzIiwiZnJvbUJ5dGVzIiwiYnl0ZXMiLCJGcFNxcnRPZGQiLCJlbG0iLCJGcFNxcnRFdmVuIiwiaGFzaFRvUHJpdmF0ZVNjYWxhciIsImhhc2giLCJncm91cE9yZGVyIiwiaGFzaExlbiIsIm1pbkxlbiIsImdldEZpZWxkQnl0ZXNMZW5ndGgiLCJmaWVsZE9yZGVyIiwiYml0TGVuZ3RoIiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwia2V5IiwibGVuIiwiZmllbGRMZW4iLCJyZWR1Y2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // Short Weierstrass curve. The formula is: y¬≤ = x¬≥ + ax + b\n\n\n\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"lowS\", opts.lowS);\n    if (opts.prehash !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"prehash\", opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowedPrivateKeyLengths: \"array\",\n        wrapPrivateKey: \"boolean\",\n        isTorsionFree: \"function\",\n        clearCofactor: \"function\",\n        allowInfinityPoint: \"boolean\",\n        fromBytes: \"function\",\n        toBytes: \"function\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"invalid endomorphism, can only be defined for Koblitz curves that have a=0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error(\"invalid endomorphism, expected beta: bigint and splitScalar: function\");\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_0__;\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ const DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = \"\"){\n            super(m);\n        }\n    },\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(len.length / 2 | 128) : \"\";\n            const t = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return b2n(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = typeof hex === \"string\" ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = _modular_js__WEBPACK_IMPORTED_MODULE_2__.Field(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error(\"bad generator point: equation left != right\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(key)) key = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"invalid private key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(\"invalid private key, expected hex or \" + nByteLength + \" bytes, got \" + typeof key);\n        }\n        if (wrapPrivateKey) num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, N); // disabled by default, enabled for BLS\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"private key\", num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ‚àã (x=x/z, y=y/z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz)=>{\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE)) return {\n            x,\n            y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x: ax,\n            y: ay\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        if (!Fp.eql(left, right)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"scalar\", sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n) return I;\n            if (this.is0() || sc === _1n) return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"scalar\", scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes() {\n            let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex() {\n            let isCompressed = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n        constructor(px, py, pz){\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n            Object.freeze(this);\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */ function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(tail);\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(x, _1n, Fp.ORDER)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error(\"invalid Point, expected length of \" + cl + \", or uncompressed \" + ul + \", got \" + len);\n            }\n        }\n    });\n    const numToNByteStr = (num)=>_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"r\", this.r, _1n, CURVE_ORDER); // r in [1..N]\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"s\", this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({\n                r: this.r,\n                s: this.s\n            });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n        constructor(r, s, recovery){\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute () {\n            let windowSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8, point = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Point.BASE;\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey) {\n        let isCompressed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(item);\n        const str = typeof item === \"string\";\n        const len = (arr || str) && item.length;\n        if (arr) return len === compressedLen || len === uncompressedLen;\n        if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point) return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB) {\n        let isCompressed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        if (isProbPub(privateA)) throw new Error(\"first arg must be private key\");\n        if (!isProbPub(publicB)) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // Our custom check \"just in case\"\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange(\"num < 2^\" + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        validateSigVerOpts(opts);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey) {\n        let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultSigOpts;\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey) {\n        let opts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : defaultVerOpts;\n        var _Point_BASE_multiplyAndAddUnsafe;\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"publicKey\", publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        if (format !== undefined && format !== \"compact\" && format !== \"der\") throw new Error(\"format must be compact or der\");\n        const isHex = typeof sg === \"string\" || _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(sg);\n        const isObj = !isHex && !format && typeof sg === \"object\" && sg !== null && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj) _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== \"compact\") _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                }\n                if (!_sig && format !== \"der\") _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            return false;\n        }\n        if (!_sig) return false;\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = (_Point_BASE_multiplyAndAddUnsafe = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _Point_BASE_multiplyAndAddUnsafe === void 0 ? void 0 : _Point_BASE_multiplyAndAddUnsafe.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n_c = SWUFpSqrtRatio;\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\nvar _c;\n$RefreshReg$(_c, \"SWUFpSqrtRatio\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLG9FQUFvRSxHQUNwRSw0REFBNEQ7QUFDQztBQUN6QjtBQUNIO0FBQ3lCO0FBQzFELFNBQVNRLG1CQUFtQkMsSUFBSTtJQUM1QixJQUFJQSxLQUFLQyxJQUFJLEtBQUtDLFdBQ2RKLGdEQUFLQSxDQUFDLFFBQVFFLEtBQUtDLElBQUk7SUFDM0IsSUFBSUQsS0FBS0csT0FBTyxLQUFLRCxXQUNqQkosZ0RBQUtBLENBQUMsV0FBV0UsS0FBS0csT0FBTztBQUNyQztBQUNBLFNBQVNDLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNTCxPQUFPVCx3REFBYUEsQ0FBQ2M7SUFDM0JWLHFEQUFpQixDQUFDSyxNQUFNO1FBQ3BCTyxHQUFHO1FBQ0hDLEdBQUc7SUFDUCxHQUFHO1FBQ0NDLDBCQUEwQjtRQUMxQkMsZ0JBQWdCO1FBQ2hCQyxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsb0JBQW9CO1FBQ3BCQyxXQUFXO1FBQ1hDLFNBQVM7SUFDYjtJQUNBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVWLENBQUMsRUFBRSxHQUFHUDtJQUN4QixJQUFJZ0IsTUFBTTtRQUNOLElBQUksQ0FBQ0MsR0FBR0MsR0FBRyxDQUFDWCxHQUFHVSxHQUFHRSxJQUFJLEdBQUc7WUFDckIsTUFBTSxJQUFJQyxNQUFNO1FBQ3BCO1FBQ0EsSUFBSSxPQUFPSixTQUFTLFlBQ2hCLE9BQU9BLEtBQUtLLElBQUksS0FBSyxZQUNyQixPQUFPTCxLQUFLTSxXQUFXLEtBQUssWUFBWTtZQUN4QyxNQUFNLElBQUlGLE1BQU07UUFDcEI7SUFDSjtJQUNBLE9BQU9HLE9BQU9DLE1BQU0sQ0FBQztRQUFFLEdBQUd4QixJQUFJO0lBQUM7QUFDbkM7QUFDQSxNQUFNLEVBQUV5QixpQkFBaUJDLEdBQUcsRUFBRUMsWUFBWUMs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QUtqVyxLQUFLZ1csQ0FBQyxHQUFHLG9CQUFvQjtRQUMvQ2IsTUFBTWxVLEdBQUd1RixHQUFHLENBQUMyTyxLQUFLRSxNQUFNLHNCQUFzQjtRQUM5Q3ZQLElBQUk3RSxHQUFHc0YsR0FBRyxDQUFDMk8sS0FBS0UsTUFBTSxzQkFBc0I7UUFDNUMsTUFBTSxFQUFFM00sT0FBTyxFQUFFa04sS0FBSyxFQUFFLEdBQUdYLFVBQVVHLEtBQUtjLE1BQU0saURBQWlEO1FBQ2pHbFEsSUFBSTlFLEdBQUdzRixHQUFHLENBQUMyTyxLQUFLRCxJQUFJLHFDQUFxQztRQUN6RGxQLElBQUk5RSxHQUFHc0YsR0FBRyxDQUFDUixHQUFHNFAsUUFBUSxtQkFBbUI7UUFDekM3UCxJQUFJN0UsR0FBR3VVLElBQUksQ0FBQzFQLEdBQUdzUCxLQUFLM00sVUFBVSx3Q0FBd0M7UUFDdEUxQyxJQUFJOUUsR0FBR3VVLElBQUksQ0FBQ3pQLEdBQUc0UCxPQUFPbE4sVUFBVSx1Q0FBdUM7UUFDdkUsTUFBTWlOLEtBQUt6VSxHQUFHZ0osS0FBSyxDQUFDZ0wsT0FBT2hVLEdBQUdnSixLQUFLLENBQUNsRSxJQUFJLCtCQUErQjtRQUN2RUEsSUFBSTlFLEdBQUd1VSxJQUFJLENBQUN2VSxHQUFHMkosR0FBRyxDQUFDN0UsSUFBSUEsR0FBRzJQLEtBQUssNEJBQTRCO1FBQzNENVAsSUFBSTdFLEdBQUdpVixHQUFHLENBQUNwUSxHQUFHd1AsTUFBTSxvQkFBb0I7UUFDeEMsT0FBTztZQUFFeFA7WUFBR0M7UUFBRTtJQUNsQjtBQUNKLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz9iNThiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgeyB2YWxpZGF0ZUJhc2ljLCB3TkFGLCBwaXBwZW5nZXIsIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMsIG1lbW9pemVkLCBhYm9vbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpIHtcbiAgICBpZiAob3B0cy5sb3dTICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFib29sKCdsb3dTJywgb3B0cy5sb3dTKTtcbiAgICBpZiAob3B0cy5wcmVoYXNoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFib29sKCdwcmVoYXNoJywgb3B0cy5wcmVoYXNoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kb21vcnBoaXNtLCBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kb21vcnBoaXNtLCBleHBlY3RlZCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG4vKipcbiAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG4gKlxuICogICAgIFsweDMwIChTRVFVRU5DRSksIGJ5dGVsZW5ndGgsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFIsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFNdXG4gKlxuICogRG9jczogaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvZG9jcy9hLXdhcm0td2VsY29tZS10by1hc24xLWFuZC1kZXIvLCBodHRwczovL2x1Y2EubnRvcC5vcmcvVGVhY2hpbmcvQXBwdW50aS9hc24xLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuICAgIF90bHY6IHtcbiAgICAgICAgZW5jb2RlOiAodGFnLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHVucGFkZGVkIGRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBkYXRhLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB1dC5udW1iZXJUb0hleFVucGFkZGVkKGRhdGFMZW4pO1xuICAgICAgICAgICAgaWYgKChsZW4ubGVuZ3RoIC8gMikgJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IGxvbmcgZm9ybSBsZW5ndGggdG9vIGJpZycpO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxlbmd0aCB3aXRoIGxvbmcgZm9ybSBmbGFnXG4gICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gdXQubnVtYmVyVG9IZXhVbnBhZGRlZCgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdCA9IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQodGFnKTtcbiAgICAgICAgICAgIHJldHVybiB0ICsgbGVuTGVuICsgbGVuICsgZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdiAtIHZhbHVlLCBsIC0gbGVmdCBieXRlcyAodW5wYXJzZWQpXG4gICAgICAgIGRlY29kZSh0YWcsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbcG9zKytdICE9PSB0YWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMTI4KTsgLy8gRmlyc3QgYml0IG9mIGZpcnN0IGxlbmd0aCBieXRlIGlzIGZsYWcgZm9yIHNob3J0L2xvbmcgZm9ybVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoIWlzTG9uZylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvbmcgZm9ybTogW2xvbmdGbGFnKDFiaXQpLCBsZW5ndGhMZW5ndGgoN2JpdCksIGxlbmd0aCAoQkUpXVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xuICAgICAgICAgICAgICAgIGlmICghbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogaW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuTGVuKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXMubGVuZ3RoICE9PSBsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiBsZW5ndGggYnl0ZXMgbm90IGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIGxlbmd0aEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIDw8IDgpIHwgYjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAxMjgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdiwgbDogZGF0YS5zdWJhcnJheShwb3MgKyBsZW5ndGgpIH07XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgX2ludDoge1xuICAgICAgICBlbmNvZGUobnVtKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKG51bSA8IF8wbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW50ZWdlcjogbmVnYXRpdmUgaW50ZWdlcnMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBsZXQgaGV4ID0gdXQubnVtYmVyVG9IZXhVbnBhZGRlZChudW0pO1xuICAgICAgICAgICAgLy8gUGFkIHdpdGggemVybyBieXRlIGlmIG5lZ2F0aXZlIGZsYWcgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChoZXhbMF0sIDE2KSAmIDBiMTAwMClcbiAgICAgICAgICAgICAgICBoZXggPSAnMDAnICsgaGV4O1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gPT09IDB4MDAgJiYgIShkYXRhWzFdICYgMTI4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgICAgICByZXR1cm4gYjJuKGRhdGEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICB1dC5hYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdjogc2VxQnl0ZXMsIGw6IHNlcUxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDMwLCBkYXRhKTtcbiAgICAgICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICBjb25zdCB7IHY6IHJCeXRlcywgbDogckxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCBzZXFCeXRlcyk7XG4gICAgICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHJMZWZ0Qnl0ZXMpO1xuICAgICAgICBpZiAoc0xlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgY29uc3QgeyBfdGx2OiB0bHYsIF9pbnQ6IGludCB9ID0gREVSO1xuICAgICAgICBjb25zdCBycyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucikpO1xuICAgICAgICBjb25zdCBzcyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucykpO1xuICAgICAgICBjb25zdCBzZXEgPSBycyArIHNzO1xuICAgICAgICByZXR1cm4gdGx2LmVuY29kZSgweDMwLCBzZXEpO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCBGbiA9IG1vZC5GaWVsZChDVVJWRS5uLCBDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHV0LmluUmFuZ2UobnVtLCBfMW4sIENVUlZFLm4pO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAodXQuaXNCeXRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5LCBleHBlY3RlZCBoZXggb3IgJyArIG5CeXRlTGVuZ3RoICsgJyBieXRlcywgZ290ICcgKyB0eXBlb2Yga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgTik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICB1dC5hSW5SYW5nZSgncHJpdmF0ZSBrZXknLCBudW0sIF8xbiwgTik7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIE1lbW9pemVkIHRvQWZmaW5lIC8gdmFsaWRpdHkgY2hlY2suIFRoZXkgYXJlIGhlYXZ5LiBQb2ludHMgYXJlIGltbXV0YWJsZS5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9IG1lbW9pemVkKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHA7XG4gICAgICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICAgICAgaWYgKEZwLmVxbCh6LCBGcC5PTkUpKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2MsIF8wbiwgTik7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChzYyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkgfHwgc2MgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIC8vIENhc2UgYTogbm8gZW5kb21vcnBoaXNtLiBDYXNlIGI6IGhhcyBwcmVjb21wdXRlcy5cbiAgICAgICAgICAgIGlmICghZW5kbyB8fCB3bmFmLmhhc1ByZWNvbXB1dGVzKHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWRVbnNhZmUodGhpcywgc2MsIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICAgICAgLy8gQ2FzZSBjOiBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpeik7XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBhbmQgRUNEU0Egc2lnbmF0dXJlIG1ldGhvZHMgZm9yIGl0LlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEZpZWxkIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJztcbiAqIC8vIEJlZm9yZSB0aGF0LCBkZWZpbmUgQmlnSW50LXM6IGEsIGIsIHAsIG4sIEd4LCBHeVxuICogY29uc3QgY3VydmUgPSB3ZWllcnN0cmFzcyh7IGEsIGIsIEZwOiBGaWVsZChwKSwgbiwgR3gsIEd5LCBoOiAxbiB9KVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghdXQuaW5SYW5nZSh4LCBfMW4sIEZwLk9SREVSKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKHNxcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXggPSBzcXJ0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/ICc6ICcgKyBzcXJ0RXJyb3IubWVzc2FnZSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsID0gY29tcHJlc3NlZExlbjtcbiAgICAgICAgICAgICAgICBjb25zdCB1bCA9IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUG9pbnQsIGV4cGVjdGVkIGxlbmd0aCBvZiAnICsgY2wgKyAnLCBvciB1bmNvbXByZXNzZWQgJyArIHVsICsgJywgZ290ICcgKyBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhlbnN1cmVCeXRlcygnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdyJywgdGhpcy5yLCBfMW4sIENVUlZFX09SREVSKTsgLy8gciBpbiBbMS4uTl1cbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdzJywgdGhpcy5zLCBfMW4sIENVUlZFX09SREVSKTsgLy8gcyBpbiBbMS4uTl1cbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBPdXIgY3VzdG9tIGNoZWNrIFwianVzdCBpbiBjYXNlXCJcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiA4MTkyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgaXMgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIHV0LmFJblJhbmdlKCdudW0gPCAyXicgKyBDVVJWRS5uQml0TGVuZ3RoLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLFxuICAgIC8vIHRoaXMgd2lsbCBiZSBpbnZhbGlkIGF0IGxlYXN0IGZvciBQNTIxLiBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCwgZm9ybWF0IH0gPSBvcHRzO1xuICAgICAgICAvLyBWZXJpZnkgb3B0cywgZGVkdWNlIHNpZ25hdHVyZSBmb3JtYXRcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgZm9ybWF0ICE9PSAnY29tcGFjdCcgJiYgZm9ybWF0ICE9PSAnZGVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IG11c3QgYmUgY29tcGFjdCBvciBkZXInKTtcbiAgICAgICAgY29uc3QgaXNIZXggPSB0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHV0LmlzQnl0ZXMoc2cpO1xuICAgICAgICBjb25zdCBpc09iaiA9ICFpc0hleCAmJlxuICAgICAgICAgICAgIWZvcm1hdCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgc2cgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnO1xuICAgICAgICBpZiAoIWlzSGV4ICYmICFpc09iailcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUsIGV4cGVjdGVkIFVpbnQ4QXJyYXksIGhleCBzdHJpbmcgb3IgU2lnbmF0dXJlIGluc3RhbmNlJyk7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc09iailcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShzZy5yLCBzZy5zKTtcbiAgICAgICAgICAgIGlmIChpc0hleCkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09ICdjb21wYWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3NpZyAmJiBmb3JtYXQgIT09ICdkZXInKVxuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfc2lnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsidmFsaWRhdGVCYXNpYyIsIndOQUYiLCJwaXBwZW5nZXIiLCJtb2QiLCJ1dCIsImVuc3VyZUJ5dGVzIiwibWVtb2l6ZWQiLCJhYm9vbCIsInZhbGlkYXRlU2lnVmVyT3B0cyIsIm9wdHMiLCJsb3dTIiwidW5kZWZpbmVkIiwicHJlaGFzaCIsInZhbGlkYXRlUG9pbnRPcHRzIiwiY3VydmUiLCJ2YWxpZGF0ZU9iamVjdCIsImEiLCJiIiwiYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIiwid3JhcFByaXZhdGVLZXkiLCJpc1RvcnNpb25GcmVlIiwiY2xlYXJDb2ZhY3RvciIsImFsbG93SW5maW5pdHlQb2ludCIsImZyb21CeXRlcyIsInRvQnl0ZXMiLCJlbmRvIiwiRnAiLCJlcWwiLCJaRVJPIiwiRXJyb3IiLCJiZXRhIiwic3BsaXRTY2FsYXIiLCJPYmplY3QiLCJmcmVlemUiLCJieXRlc1RvTnVtYmVyQkUiLCJiMm4iLCJoZXhUb0J5dGVzIiwiaDJiIiwiREVSIiwiRXJyIiwiREVSRXJyIiwiY29uc3RydWN0b3IiLCJtIiwiX3RsdiIsImVuY29kZSIsInRhZyIsImRhdGEiLCJFIiwibGVuZ3RoIiwiZGF0YUxlbiIsImxlbiIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJsZW5MZW4iLCJ0IiwiZGVjb2RlIiwicG9zIiwiZmlyc3QiLCJpc0xvbmciLCJsZW5ndGhCeXRlcyIsInN1YmFycmF5IiwidiIsImwiLCJfaW50IiwibnVtIiwiXzBuIiwiaGV4IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJ0b1NpZyIsImludCIsInRsdiIsImFieXRlcyIsInNlcUJ5dGVzIiwic2VxTGVmdEJ5dGVzIiwickJ5dGVzIiwickxlZnRCeXRlcyIsInNCeXRlcyIsInNMZWZ0Qnl0ZXMiLCJyIiwicyIsImhleEZyb21TaWciLCJzaWciLCJycyIsInNzIiwic2VxIiwiQmlnSW50IiwiXzFuIiwiXzJuIiwiXzNuIiwiXzRuIiwid2VpZXJzdHJhc3NQb2ludHMiLCJDVVJWRSIsIkZuIiwiRmllbGQiLCJuIiwibkJpdExlbmd0aCIsIl9jIiwicG9pbnQiLCJfaXNDb21wcmVzc2VkIiwidG9BZmZpbmUiLCJjb25jYXRCeXRlcyIsIlVpbnQ4QXJyYXkiLCJmcm9tIiwieCIsInkiLCJieXRlcyIsInRhaWwiLCJCWVRFUyIsIndlaWVyc3RyYXNzRXF1YXRpb24iLCJ4MiIsInNxciIsIngzIiwibXVsIiwiYWRkIiwiR3kiLCJHeCIsImlzV2l0aGluQ3VydmVPcmRlciIsImluUmFuZ2UiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwia2V5IiwibGVuZ3RocyIsIm5CeXRlTGVuZ3RoIiwiTiIsImlzQnl0ZXMiLCJieXRlc1RvSGV4IiwiaW5jbHVkZXMiLCJwYWRTdGFydCIsImVycm9yIiwiYUluUmFuZ2UiLCJhc3NlcnRQcmpQb2ludCIsIm90aGVyIiwiUG9pbnQiLCJ0b0FmZmluZU1lbW8iLCJwIiwiaXoiLCJweCIsInB5IiwicHoiLCJ6IiwiT05FIiwiaXMwIiwiaW52IiwiYXgiLCJheSIsInp6IiwiYXNzZXJ0VmFsaWRNZW1vIiwiaXNWYWxpZCIsImxlZnQiLCJyaWdodCIsImZyb21BZmZpbmUiLCJpIiwibm9ybWFsaXplWiIsInBvaW50cyIsInRvSW52IiwiaW52ZXJ0QmF0Y2giLCJtYXAiLCJmcm9tSGV4IiwiUCIsImFzc2VydFZhbGlkaXR5IiwiZnJvbVByaXZhdGVLZXkiLCJwcml2YXRlS2V5IiwiQkFTRSIsIm11bHRpcGx5IiwibXNtIiwic2NhbGFycyIsIl9zZXRXaW5kb3dTaXplIiwid2luZG93U2l6ZSIsInduYWYiLCJzZXRXaW5kb3dTaXplIiwiaGFzRXZlblkiLCJpc09kZCIsImVxdWFscyIsIlgxIiwiWTEiLCJaMSIsIlgyIiwiWTIiLCJaMiIsIlUxIiwiVTIiLCJuZWdhdGUiLCJuZWciLCJkb3VibGUiLCJiMyIsIlgzIiwiWTMiLCJaMyIsInQwIiwidDEiLCJ0MiIsInQzIiwic3ViIiwidDQiLCJ0NSIsInN1YnRyYWN0Iiwid05BRkNhY2hlZCIsIm11bHRpcGx5VW5zYWZlIiwic2MiLCJJIiwiaGFzUHJlY29tcHV0ZXMiLCJ3TkFGQ2FjaGVkVW5zYWZlIiwiazFuZWciLCJrMSIsImsybmVnIiwiazIiLCJrMXAiLCJrMnAiLCJkIiwic2NhbGFyIiwiZmFrZSIsImYiLCJmMXAiLCJmMnAiLCJjb25zdFRpbWVOZWdhdGUiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsIlEiLCJHIiwic3VtIiwiaCIsImNvZmFjdG9yIiwidG9SYXdCeXRlcyIsImlzQ29tcHJlc3NlZCIsInRvSGV4IiwiX2JpdHMiLCJNYXRoIiwiY2VpbCIsIlByb2plY3RpdmVQb2ludCIsInZhbGlkYXRlT3B0cyIsImhhc2giLCJobWFjIiwicmFuZG9tQnl0ZXMiLCJiaXRzMmludCIsImJpdHMyaW50X21vZE4iLCJ3ZWllcnN0cmFzcyIsImN1cnZlRGVmIiwiQ1VSVkVfT1JERVIiLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwibW9kTiIsImludk4iLCJpbnZlcnQiLCJjYXQiLCJoZWFkIiwiT1JERVIiLCJ5MiIsInNxcnQiLCJzcXJ0RXJyb3IiLCJzdWZmaXgiLCJtZXNzYWdlIiwiaXNZT2RkIiwiaXNIZWFkT2RkIiwiY2wiLCJ1bCIsIm51bVRvTkJ5dGVTdHIiLCJudW1iZXJUb0J5dGVzQkUiLCJpc0JpZ2dlclRoYW5IYWxmT3JkZXIiLCJudW1iZXIiLCJIQUxGIiwibm9ybWFsaXplUyIsInNsY051bSIsInRvIiwic2xpY2UiLCJTaWduYXR1cmUiLCJmcm9tQ29tcGFjdCIsImZyb21ERVIiLCJhZGRSZWNvdmVyeUJpdCIsInJlY292ZXJ5IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwicHJlZml4IiwiUiIsImlyIiwidTEiLCJ1MiIsImhhc0hpZ2hTIiwidG9ERVJSYXdCeXRlcyIsInRvREVSSGV4IiwidG9Db21wYWN0UmF3Qnl0ZXMiLCJ0b0NvbXBhY3RIZXgiLCJ1dGlscyIsImlzVmFsaWRQcml2YXRlS2V5IiwicmFuZG9tUHJpdmF0ZUtleSIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsInByZWNvbXB1dGUiLCJnZXRQdWJsaWNLZXkiLCJpc1Byb2JQdWIiLCJpdGVtIiwiYXJyIiwic3RyIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiYml0TWFzayIsImludDJvY3RldHMiLCJwcmVwU2lnIiwiZGVmYXVsdFNpZ09wdHMiLCJzb21lIiwiayIsImV4dHJhRW50cm9weSIsImVudCIsImgxaW50Iiwic2VlZEFyZ3MiLCJlIiwicHVzaCIsInNlZWQiLCJrMnNpZyIsImtCeXRlcyIsImlrIiwicSIsIm5vcm1TIiwiZGVmYXVsdFZlck9wdHMiLCJzaWduIiwicHJpdktleSIsIkMiLCJkcmJnIiwiY3JlYXRlSG1hY0RyYmciLCJvdXRwdXRMZW4iLCJ2ZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJzZyIsImZvcm1hdCIsImlzSGV4IiwiaXNPYmoiLCJfc2lnIiwiZGVyRXJyb3IiLCJpcyIsIlNXVUZwU3FydFJhdGlvIiwiWiIsIm8iLCJjMSIsIl8ybl9wb3dfYzFfMSIsIl8ybl9wb3dfYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImM2IiwicG93IiwiYzciLCJzcXJ0UmF0aW8iLCJ1IiwidHYxIiwidHYyIiwidHYzIiwidHY1IiwidHY0IiwiaXNRUiIsImNtb3YiLCJ0dnY1IiwiZTEiLCJ2YWx1ZSIsInkxIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsInZhbGlkYXRlRmllbGQiLCJBIiwiQiIsInR2NiIsImRpdiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   schnorr: function() { return /* binding */ schnorr; },\n/* harmony export */   secp256k1: function() { return /* binding */ secp256k1; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n */ const secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */ endo: {\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag) {\n    for(var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        messages[_key - 1] = arguments[_key];\n    }\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n_c = GmulAdd;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)(\"x\", x, _1n, secp256k1P); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey) {\n    let auxRand = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n */ const schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\nconst htf = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>htf.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\nvar _c;\n$RefreshReg$(_c, \"GmulAdd\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxvRUFBb0UsR0FDdEI7QUFDSTtBQUNEO0FBQ3NCO0FBQ2Q7QUFDNEQ7QUFDckQ7QUFDaEUsTUFBTWUsYUFBYUMsT0FBTztBQUMxQixNQUFNQyxhQUFhRCxPQUFPO0FBQzFCLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsTUFBTUcsTUFBTUgsT0FBTztBQUNuQixNQUFNSSxhQUFhLENBQUNDLEdBQUdDLElBQU0sQ0FBQ0QsSUFBSUMsSUFBSUgsR0FBRSxJQUFLRztBQUM3Qzs7O0NBR0MsR0FDRCxTQUFTQyxRQUFRQyxDQUFDO0lBQ2QsTUFBTUMsSUFBSVY7SUFDVixrQkFBa0I7SUFDbEIsTUFBTVcsTUFBTVYsT0FBTyxJQUFJVyxNQUFNWCxPQUFPLElBQUlZLE9BQU9aLE9BQU8sS0FBS2EsT0FBT2IsT0FBTztJQUN6RSxrQkFBa0I7SUFDbEIsTUFBTWMsT0FBT2QsT0FBTyxLQUFLZSxPQUFPZixPQUFPLEtBQUtnQixPQUFPaEIsT0FBTztJQUMxRCxNQUFNaUIsS0FBSyxJQUFLVCxJQUFJQSxJQUFLQyxHQUFHLFVBQVU7SUFDdEMsTUFBTVMsS0FBSyxLQUFNRCxLQUFLVCxJQUFLQyxHQUFHLE1BQU07SUFDcEMsTUFBTVUsS0FBSywyREFBTUQsSUFBSVIsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDckMsTUFBTVcsS0FBSywyREFBTUQsSUFBSVQsS0FBS0QsS0FBS1MsS0FBTVQ7SUFDckMsTUFBTVksTUFBTSwyREFBTUQsSUFBSWpCLEtBQUtNLEtBQUtRLEtBQU1SO0lBQ3RDLE1BQU1hLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1ILEtBQUtZLE1BQU9aO0lBQ3pDLE1BQU1jLE1BQU0sMkRBQU1ELEtBQUtULE1BQU1KLEtBQUthLE1BQU9iO0lBQ3pDLE1BQU1lLE1BQU0sMkRBQU1ELEtBQUtSLE1BQU1OLEtB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S0FBSytHLEtBQUs7UUFDYnRDLEdBQUc7UUFDSHpELEdBQUc7UUFDSGdHLFFBQVE7UUFDUkMsTUFBTWhLLHdEQUFNQTtJQUNoQixFQUFDO0FBQ00sTUFBTWlLLGNBQThCLGFBQUgsR0FBSSxLQUFNUCxJQUFJTyxXQUFXLElBQUk7QUFDOUQsTUFBTUMsZ0JBQWdDLGFBQUgsR0FBSSxLQUFNUixJQUFJUSxhQUFhLElBQUksQ0FDekUscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/ZDEyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgaW5SYW5nZSwgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gcG93Mih0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwazEuZXFsKEZwazEuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnBrMSA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG4vKipcbiAqIHNlY3AyNTZrMSBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBhbmQgRUNEU0Egc2lnbmF0dXJlcyBvdmVyIGl0LlxuICovXG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IEJpZ0ludCgwKSwgLy8gZXF1YXRpb24gcGFyYW1zOiBhLCBiXG4gICAgYjogQmlnSW50KDcpLCAvLyBTZWVtIHRvIGJlIHJpZ2lkOiBiaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzVcbiAgICBGcDogRnBrMSwgLy8gRmllbGQncyBwcmltZTogMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5cbiAgICBuOiBzZWNwMjU2azFOLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGFJblJhbmdlKCd4JywgeCwgXzFuLCBzZWNwMjU2azFQKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbmNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihudW0ocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3gobnVtKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IG51bShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWluUmFuZ2UociwgXzFuLCBzZWNwMjU2azFQKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9IG51bShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG4gICAgICAgIGlmICghaW5SYW5nZShzLCBfMW4sIHNlY3AyNTZrMU4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFNjaG5vcnIgc2lnbmF0dXJlcyBvdmVyIHNlY3AyNTZrMS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwazEsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnBrMS5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwazEuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyNTYsXG59KSkoKTtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6WyJzaGEyNTYiLCJyYW5kb21CeXRlcyIsImNyZWF0ZUN1cnZlIiwiY3JlYXRlSGFzaGVyIiwiaXNvZ2VueU1hcCIsIkZpZWxkIiwibW9kIiwicG93MiIsImluUmFuZ2UiLCJhSW5SYW5nZSIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJudW1iZXJUb0J5dGVzQkUiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwic2VjcDI1NmsxUCIsIkJpZ0ludCIsInNlY3AyNTZrMU4iLCJfMW4iLCJfMm4iLCJkaXZOZWFyZXN0IiwiYSIsImIiLCJzcXJ0TW9kIiwieSIsIlAiLCJfM24iLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImIyIiwiYjMiLCJiNiIsImI5IiwiYjExIiwiYjIyIiwiYjQ0IiwiYjg4IiwiYjE3NiIsImIyMjAiLCJiMjIzIiwidDEiLCJ0MiIsInJvb3QiLCJGcGsxIiwiZXFsIiwic3FyIiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJzcXJ0Iiwic2VjcDI1NmsxIiwiRnAiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiZW5kbyIsImJldGEiLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJjMSIsImMyIiwiazEiLCJrMiIsImsxbmVnIiwiazJuZWciLCJfMG4iLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ0YWdIIiwiVWludDhBcnJheSIsImZyb20iLCJjIiwiY2hhckNvZGVBdCIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9SYXdCeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJtb2RQIiwieCIsIm1vZE4iLCJQb2ludCIsIlByb2plY3RpdmVQb2ludCIsIkdtdWxBZGQiLCJRIiwiQkFTRSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJkXyIsInV0aWxzIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsInAiLCJmcm9tUHJpdmF0ZUtleSIsInNjYWxhciIsImhhc0V2ZW5ZIiwiYnl0ZXMiLCJsaWZ0X3giLCJ4eCIsImFzc2VydFZhbGlkaXR5IiwibnVtIiwiY2hhbGxlbmdlIiwiYXJncyIsInNjaG5vcnJHZXRQdWJsaWNLZXkiLCJwcml2YXRlS2V5Iiwic2Nobm9yclNpZ24iLCJtZXNzYWdlIiwiYXV4UmFuZCIsIm0iLCJweCIsImQiLCJ0IiwicmFuZCIsImtfIiwicngiLCJlIiwic2lnIiwic2V0Iiwic2Nobm9yclZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInB1YiIsInIiLCJzdWJhcnJheSIsInMiLCJSIiwidG9BZmZpbmUiLCJlcnJvciIsInNjaG5vcnIiLCJnZXRQdWJsaWNLZXkiLCJzaWduIiwidmVyaWZ5IiwicmFuZG9tUHJpdmF0ZUtleSIsImlzb01hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwiQSIsIkIiLCJaIiwiY3JlYXRlIiwiaHRmIiwic2NhbGFycyIsIkRTVCIsImVuY29kZURTVCIsIk9SREVSIiwiZXhwYW5kIiwiaGFzaCIsImhhc2hUb0N1cnZlIiwiZW5jb2RlVG9DdXJ2ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: function() { return /* binding */ abytes; },\n/* harmony export */   aexists: function() { return /* binding */ aexists; },\n/* harmony export */   ahash: function() { return /* binding */ ahash; },\n/* harmony export */   anumber: function() { return /* binding */ anumber; },\n/* harmony export */   aoutput: function() { return /* binding */ aoutput; },\n/* harmony export */   bytes: function() { return /* binding */ abytes; },\n/* harmony export */   number: function() { return /* binding */ anumber; }\n/* harmony export */ });\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, got \" + n);\n}\n// copied from utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(b) {\n    for(var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        lengths[_key - 1] = arguments[_key];\n    }\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\nfunction ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance) {\n    let checkFinished = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n}\n\nconst assert = {\n    number: anumber,\n    bytes: abytes,\n    hash: ahash,\n    exists: aexists,\n    output: aoutput\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert); //# sourceMappingURL=_assert.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxRQUFRQyxDQUFDO0lBQ2QsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FDaEMsTUFBTSxJQUFJRyxNQUFNLG9DQUFvQ0g7QUFDNUQ7QUFDQSxvQkFBb0I7QUFDcEIsU0FBU0ksUUFBUUMsQ0FBQztJQUNkLE9BQU9BLGFBQWFDLGNBQWVDLFlBQVlDLE1BQU0sQ0FBQ0gsTUFBTUEsRUFBRUksV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdkY7QUFDQSxTQUFTQyxPQUFPQyxDQUFDO0lBQUU7UUFBR0MsUUFBSCwyQkFBVTs7SUFDekIsSUFBSSxDQUFDVCxRQUFRUSxJQUNULE1BQU0sSUFBSVQsTUFBTTtJQUNwQixJQUFJVSxRQUFRQyxNQUFNLEdBQUcsS0FBSyxDQUFDRCxRQUFRRSxRQUFRLENBQUNILEVBQUVFLE1BQU0sR0FDaEQsTUFBTSxJQUFJWCxNQUFNLG1DQUFtQ1UsVUFBVSxrQkFBa0JELEVBQUVFLE1BQU07QUFDL0Y7QUFDQSxTQUFTRSxNQUFNQyxDQUFDO0lBQ1osSUFBSSxPQUFPQSxNQUFNLGNBQWMsT0FBT0EsRUFBRUMsTUFBTSxLQUFLLFlBQy9DLE1BQU0sSUFBSWYsTUFBTTtJQUNwQkosUUFBUWtCLEVBQUVFLFNBQVM7SUFDbkJwQixRQUFRa0IsRUFBRUcsUUFBUTtBQUN0QjtBQUNBLFNBQVNDLFFBQVFDLFFBQVE7UUFBRUMsZ0JBQUFBLGlFQUFnQjtJQUN2QyxJQUFJRCxTQUFTRSxTQUFTLEVBQ2xCLE1BQU0sSUFBSXJCLE1BQU07SUFDcEIsSUFBSW9CLGlCQUFpQkQsU0FBU0csUUFBUSxFQUNsQyxNQUFNLElBQUl0QixNQUFNO0FBQ3hCO0FBQ0EsU0FBU3VCLFFBQVFDLEdBQUcsRUFBRUwsUUFBUTtJQUMxQlgsT0FBT2dCO0lBQ1AsTUFBTUMsTUFBTU4sU0FBU0gsU0FBUztJQUM5QixJQUFJUSxJQUFJYixNQUFNLEdBQUdjLEtBQUs7UUFDbEIsTUFBTSxJQUFJekIsTUFBTSwyREFBMkR5QjtJQUMvRTtBQUNKO0FBQ3dGO0FBQ3hGLE1BQU1HLFNBQVM7SUFDWEYsUUFBUTlCO0lBQ1IrQixPQUFPbkI7SUFDUHFCLE1BQU1oQjtJQUNOaUIsUUFBUVo7SUFDUmEsUUFBUVI7QUFDWjtBQUNBLCtEQUFlSyxNQUFNQSxFQUFDLENBQ3RCLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcz9kNWRkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgZ290ICcgKyBuKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG5mdW5jdGlvbiBhYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJyArIGxlbmd0aHMgKyAnLCBnb3QgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBhaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG5leHBvcnQgeyBhbnVtYmVyLCBhbnVtYmVyIGFzIG51bWJlciwgYWJ5dGVzLCBhYnl0ZXMgYXMgYnl0ZXMsIGFoYXNoLCBhZXhpc3RzLCBhb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyOiBhbnVtYmVyLFxuICAgIGJ5dGVzOiBhYnl0ZXMsXG4gICAgaGFzaDogYWhhc2gsXG4gICAgZXhpc3RzOiBhZXhpc3RzLFxuICAgIG91dHB1dDogYW91dHB1dCxcbn07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6WyJhbnVtYmVyIiwibiIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYWJ5dGVzIiwiYiIsImxlbmd0aHMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImFoYXNoIiwiaCIsImNyZWF0ZSIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiYWV4aXN0cyIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwiYW91dHB1dCIsIm91dCIsIm1pbiIsIm51bWJlciIsImJ5dGVzIiwiYXNzZXJ0IiwiaGFzaCIsImV4aXN0cyIsIm91dHB1dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: function() { return /* binding */ Chi; },\n/* harmony export */   HashMD: function() { return /* binding */ HashMD; },\n/* harmony export */   Maj: function() { return /* binding */ Maj; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n/**\n * Polyfill for Safari 14\n */ function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/**\n * Choice: a ? b : c\n */ const Chi = (a, b, c)=>a & b ^ ~a & c;\n_c = Chi;\n/**\n * Majority function, true if any two inputs is true\n */ const Maj = (a, b, c)=>a & b ^ a & c ^ b & c;\n_c1 = Maj;\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n} //# sourceMappingURL=_md.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Chi\");\n$RefreshReg$(_c1, \"Maj\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0Q7QUFDTztBQUN2RDs7Q0FFQyxHQUNELFNBQVNLLGFBQWFDLElBQUksRUFBRUMsVUFBVSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFDL0MsSUFBSSxPQUFPSCxLQUFLRCxZQUFZLEtBQUssWUFDN0IsT0FBT0MsS0FBS0QsWUFBWSxDQUFDRSxZQUFZQyxPQUFPQztJQUNoRCxNQUFNQyxPQUFPQyxPQUFPO0lBQ3BCLE1BQU1DLFdBQVdELE9BQU87SUFDeEIsTUFBTUUsS0FBS0MsT0FBTyxTQUFVSixPQUFRRTtJQUNwQyxNQUFNRyxLQUFLRCxPQUFPTixRQUFRSTtJQUMxQixNQUFNSSxJQUFJUCxPQUFPLElBQUk7SUFDckIsTUFBTVEsSUFBSVIsT0FBTyxJQUFJO0lBQ3JCSCxLQUFLWSxTQUFTLENBQUNYLGFBQWFTLEdBQUdILElBQUlKO0lBQ25DSCxLQUFLWSxTQUFTLENBQUNYLGFBQWFVLEdBQUdGLElBQUlOO0FBQ3ZDO0FBQ0E7O0NBRUMsR0FDTSxNQUFNVSxNQUFNLENBQUNDLEdBQUdDLEdBQUdDLElBQU0sSUFBS0QsSUFBTSxDQUFDRCxJQUFJRSxFQUFHO0tBQXRDSDtBQUNiOztDQUVDLEdBQ00sTUFBTUksTUFBTSxDQUFDSCxHQUFHQyxHQUFHQyxJQUFNLElBQUtELElBQU1ELElBQUlFLElBQU1ELElBQUlDLEVBQUc7TUFBL0NDO0FBQ2I7OztDQUdDLEdBQ00sTUFBTUMsZUFBZXRCLDJDQUFJQTtJQWM1QnVCLE9BQU9DLElBQUksRUFBRTtRQUNUMUIsbURBQU9BLENBQUMsSUFBSTtRQUNaLE1BQU0sRUFBRU0sSUFBSSxFQUFFcUIsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBRyxJQUFJO1FBQ3ZDRixPQUFPdEIsa0RBQU9BLENBQUNzQjtRQUNmLE1BQU1HLE1B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QUFFO1FBQ1hBLE1BQU9BLENBQUFBLEtBQUssSUFBSSxJQUFJLENBQUNDLFdBQVcsRUFBQztRQUNqQ0QsR0FBR3BCLEdBQUcsSUFBSSxJQUFJLENBQUNjLEdBQUc7UUFDbEIsTUFBTSxFQUFFdkIsUUFBUSxFQUFFRCxNQUFNLEVBQUVHLE1BQU0sRUFBRVksUUFBUSxFQUFFaUIsU0FBUyxFQUFFNUIsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNuRTBCLEdBQUczQixNQUFNLEdBQUdBO1FBQ1oyQixHQUFHMUIsR0FBRyxHQUFHQTtRQUNUMEIsR0FBR2YsUUFBUSxHQUFHQTtRQUNkZSxHQUFHRSxTQUFTLEdBQUdBO1FBQ2YsSUFBSTdCLFNBQVNGLFVBQ1Q2QixHQUFHOUIsTUFBTSxDQUFDVSxHQUFHLENBQUNWO1FBQ2xCLE9BQU84QjtJQUNYO0lBL0ZBQyxZQUFZOUIsUUFBUSxFQUFFbUIsU0FBUyxFQUFFSCxTQUFTLEVBQUVuQyxJQUFJLENBQUU7UUFDOUMsS0FBSztRQUNMLElBQUksQ0FBQ21CLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDbUIsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNILFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDbkMsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ2lDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNaLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDNEIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ2hDLE1BQU0sR0FBRyxJQUFJaUMsV0FBV2hDO1FBQzdCLElBQUksQ0FBQ3RCLElBQUksR0FBR0gscURBQVVBLENBQUMsSUFBSSxDQUFDd0IsTUFBTTtJQUN0QztBQW9GSixFQUNBLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzPzE0ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWV4aXN0cywgYW91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vKipcbiAqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbiAqL1xuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKlxuICogQ2hvaWNlOiBhID8gYiA6IGNcbiAqL1xuZXhwb3J0IGNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vKipcbiAqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWVcbiAqL1xuZXhwb3J0IGNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6WyJhZXhpc3RzIiwiYW91dHB1dCIsIkhhc2giLCJjcmVhdGVWaWV3IiwidG9CeXRlcyIsInNldEJpZ1VpbnQ2NCIsInZpZXciLCJieXRlT2Zmc2V0IiwidmFsdWUiLCJpc0xFIiwiXzMybiIsIkJpZ0ludCIsIl91MzJfbWF4Iiwid2giLCJOdW1iZXIiLCJ3bCIsImgiLCJsIiwic2V0VWludDMyIiwiQ2hpIiwiYSIsImIiLCJjIiwiTWFqIiwiSGFzaE1EIiwidXBkYXRlIiwiZGF0YSIsImJ1ZmZlciIsImJsb2NrTGVuIiwibGVuIiwibGVuZ3RoIiwicG9zIiwidGFrZSIsIk1hdGgiLCJtaW4iLCJkYXRhVmlldyIsInByb2Nlc3MiLCJzZXQiLCJzdWJhcnJheSIsInJvdW5kQ2xlYW4iLCJkaWdlc3RJbnRvIiwib3V0IiwiZmluaXNoZWQiLCJmaWxsIiwicGFkT2Zmc2V0IiwiaSIsIm92aWV3Iiwib3V0cHV0TGVuIiwiRXJyb3IiLCJvdXRMZW4iLCJzdGF0ZSIsImdldCIsImRpZ2VzdCIsInJlcyIsInNsaWNlIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsImNvbnN0cnVjdG9yIiwiZGVzdHJveWVkIiwiVWludDhBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined; //# sourceMappingURL=crypto.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLFNBQVMsT0FBT0MsZUFBZSxZQUFZLFlBQVlBLGFBQWFBLFdBQVdELE1BQU0sR0FBR0UsVUFBVSxDQUMvRyxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcz83MzMyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6WyJjcnlwdG8iLCJnbG9iYWxUaGlzIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: function() { return /* binding */ HMAC; },\n/* harmony export */   hmac: function() { return /* binding */ hmac; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0Q7QUFDWDtBQUMzQyxrQkFBa0I7QUFDWCxNQUFNSyxhQUFhRiwyQ0FBSUE7SUEyQjFCRyxPQUFPQyxHQUFHLEVBQUU7UUFDUkwsbURBQU9BLENBQUMsSUFBSTtRQUNaLElBQUksQ0FBQ00sS0FBSyxDQUFDRixNQUFNLENBQUNDO1FBQ2xCLE9BQU8sSUFBSTtJQUNmO0lBQ0FFLFdBQVdDLEdBQUcsRUFBRTtRQUNaUixtREFBT0EsQ0FBQyxJQUFJO1FBQ1pELGtEQUFNQSxDQUFDUyxLQUFLLElBQUksQ0FBQ0MsU0FBUztRQUMxQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNKLEtBQUssQ0FBQ0MsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNHLEtBQUssQ0FBQ1AsTUFBTSxDQUFDSTtRQUNsQixJQUFJLENBQUNHLEtBQUssQ0FBQ0osVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNJLE9BQU87SUFDaEI7SUFDQUMsU0FBUztRQUNMLE1BQU1MLE1BQU0sSUFBSU0sV0FBVyxJQUFJLENBQUNILEtBQUssQ0FBQ0YsU0FBUztRQUMvQyxJQUFJLENBQUNGLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBTyxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUtDLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0UsY0FBYyxDQUFDLElBQUksR0FBRyxDQUFDLEVBQUM7UUFDekQsTUFBTSxFQUFFUixLQUFLLEVBQUVMLEtBQUssRUFBRUksUUFBUSxFQUFFVSxTQUFTLEVBQUVDLFFBQVEsRUFBRVosU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUN2RU8sS0FBS0E7UUFDTEEsR0FBR04sUUFBUSxHQUFHQTtRQUNkTSxHQUFHSSxTQUFTLEdBQUdBO1FBQ2ZKLEdBQUdLLFFBQVEsR0FBR0E7UUFDZEwsR0FBR1AsU0FBUyxHQUFHQTtRQUNmTyxHQUFHTCxLQUFLLEdBQUdBLE1BQU1JLFVBQVUsQ0FBQ0MsR0FBR0wsS0FBSztRQUNwQ0ssR0FBR1YsS0FBSyxHQUFHQSxNQUFNUyxVQUFVLENBQUNDLEdBQUdWLEtBQUs7UUFDcEMsT0FBT1U7SUFDWDtJQUNBSixVQUFVO1FBQ04sSUFBSSxDQUFDUSxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDVCxLQUFLLENBQUNDLE9BQU87UUFDbEIsSUFBSSxDQUFDTixLQUFLLENBQUNNLE9BQU87SUFDdEI7SUE5REFVLFlBQVlDLElBQUksRUFBRUMsSUFBSSxDQUFFO1FBQ3BCLEtBQUs7UUFDTCxJQUFJLENBQUNkLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNVLFNBQVMsR0FBRztRQUNqQnRCLGlEQUFLQSxDQUFDeUI7UUFDTixNQUFNRSxNQUFNdkIsa0RBQU9BLENBQUNzQjtRQUNwQixJQUFJLENBQUNsQixLQUFLLEdBQUdpQixLQUFLTCxNQUFNO1FBQ3hCLElBQUksT0FBTyxJQUFJLENBQUNaLEtBQUssQ0FBQ0YsTUFBTSxLQUFLLFlBQzdCLE1BQU0sSUFBSXNCLE1BQU07UUFDcEIsSUFBSSxDQUFDTCxRQUFRLEdBQUcsSUFBSSxDQUFDZixLQUFLLENBQUNlLFFBQVE7UUFDbkMsSUFBSSxDQUFDWixTQUFTLEdBQUcsSUFBSSxDQUFDSCxLQUFLLENBQUNHLFNBQVM7UUFDckMsTUFBTVksV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTU0sTUFBTSxJQUFJYixXQUFXTztRQUMzQix3Q0FBd0M7UUFDeENNLElBQUlDLEdBQUcsQ0FBQ0gsSUFBSUksTUFBTSxHQUFHUixXQUFXRSxLQUFLTCxNQUFNLEdBQUdkLE1BQU0sQ0FBQ3FCLEtBQUtaLE1BQU0sS0FBS1k7UUFDckUsSUFBSyxJQUFJSyxJQUFJLEdBQUdBLElBQUlILElBQUlFLE1BQU0sRUFBRUMsSUFDNUJILEdBQUcsQ0FBQ0csRUFBRSxJQUFJO1FBQ2QsSUFBSSxDQUFDeEIsS0FBSyxDQUFDRixNQUFNLENBQUN1QjtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDaEIsS0FBSyxHQUFHWSxLQUFLTCxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSUgsSUFBSUUsTUFBTSxFQUFFQyxJQUM1QkgsR0FBRyxDQUFDRyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNuQixLQUFLLENBQUNQLE1BQU0sQ0FBQ3VCO1FBQ2xCQSxJQUFJSSxJQUFJLENBQUM7SUFDYjtBQXNDSjtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLE9BQU8sQ0FBQ1QsTUFBTUUsS0FBS1EsVUFBWSxJQUFJOUIsS0FBS29CLE1BQU1FLEtBQUtyQixNQUFNLENBQUM2QixTQUFTcEIsTUFBTSxHQUFHO0FBQ3pGbUIsS0FBS2QsTUFBTSxHQUFHLENBQUNLLE1BQU1FLE1BQVEsSUFBSXRCLEtBQUtvQixNQUFNRSxNQUM1QyxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanM/ZjczYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhaGFzaCwgYWJ5dGVzLCBhZXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYWhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbiAqIGltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG4gKiBjb25zdCBtYWMxID0gaG1hYyhzaGEyNTYsICdrZXknLCAnbWVzc2FnZScpO1xuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOlsiYWhhc2giLCJhYnl0ZXMiLCJhZXhpc3RzIiwiSGFzaCIsInRvQnl0ZXMiLCJITUFDIiwidXBkYXRlIiwiYnVmIiwiaUhhc2giLCJkaWdlc3RJbnRvIiwib3V0Iiwib3V0cHV0TGVuIiwiZmluaXNoZWQiLCJvSGFzaCIsImRlc3Ryb3kiLCJkaWdlc3QiLCJVaW50OEFycmF5IiwiX2Nsb25lSW50byIsInRvIiwiT2JqZWN0IiwiY3JlYXRlIiwiZ2V0UHJvdG90eXBlT2YiLCJkZXN0cm95ZWQiLCJibG9ja0xlbiIsImNvbnN0cnVjdG9yIiwiaGFzaCIsIl9rZXkiLCJrZXkiLCJFcnJvciIsInBhZCIsInNldCIsImxlbmd0aCIsImkiLCJmaWxsIiwiaG1hYyIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA256: function() { return /* binding */ SHA256; },\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per late 2024.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n    constructor(){\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor(){\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA256());\n/**\n * SHA2-224 hash function\n */ const sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(()=>new SHA224()); //# sourceMappingURL=sha256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNEM7QUFDTztBQUNuRCxnRUFBZ0U7QUFDaEUsNEVBQTRFO0FBQzVFLG1CQUFtQjtBQUNuQix5RkFBeUY7QUFDekYsa0JBQWtCO0FBQ2xCLE1BQU1LLFdBQVcsYUFBYSxHQUFHLElBQUlDLFlBQVk7SUFDN0M7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsaUJBQWlCO0FBQ2pCLHdGQUF3RjtBQUN4RixrQkFBa0I7QUFDbEIsTUFBTUMsWUFBWSxhQUFhLEdBQUcsSUFBSUQsWUFBWTtJQUM5QztJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsNERBQTREO0FBQzVELG1EQUFtRDtBQUNuRCxNQUFNRSxXQUFXLGFBQWEsR0FBRyxJQUFJRixZQUFZO0FBQzFDLE1BQU1HLGVBQWVULDBDQUFNQTtJQWM5QlUsTUFBTTtRQUNGLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFD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QyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNDLENBQUMsR0FBRyxhQUFhO1FBQ3RCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHLGFBQWE7UUFDdEIsSUFBSSxDQUFDQyxDQUFDLEdBQUcsYUFBYTtRQUN0QixJQUFJLENBQUNxQixTQUFTLEdBQUc7SUFDckI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1DLFNBQVMsYUFBYSxHQUFHcEMsMERBQWVBLENBQUMsSUFBTSxJQUFJSyxVQUFVO0FBQzFFOztDQUVDLEdBQ00sTUFBTWdDLFNBQVMsYUFBYSxHQUFHckMsMERBQWVBLENBQUMsSUFBTSxJQUFJa0MsVUFBVSxDQUMxRSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcz9hZTlmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc2hNRCwgQ2hpLCBNYWogfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIGxhdGUgMjAyNC5cbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGU6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5leHBvcnQgY2xhc3MgU0hBMjU2IGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBTSEEyNTZfSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuLyoqXG4gKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbIkhhc2hNRCIsIkNoaSIsIk1haiIsInJvdHIiLCJ3cmFwQ29uc3RydWN0b3IiLCJTSEEyNTZfSyIsIlVpbnQzMkFycmF5IiwiU0hBMjU2X0lWIiwiU0hBMjU2X1ciLCJTSEEyNTYiLCJnZXQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsInNldCIsInByb2Nlc3MiLCJ2aWV3Iiwib2Zmc2V0IiwiaSIsImdldFVpbnQzMiIsIlcxNSIsIlcyIiwiczAiLCJzMSIsInNpZ21hMSIsIlQxIiwic2lnbWEwIiwiVDIiLCJyb3VuZENsZWFuIiwiZmlsbCIsImRlc3Ryb3kiLCJidWZmZXIiLCJjb25zdHJ1Y3RvciIsIlNIQTIyNCIsIm91dHB1dExlbiIsInNoYTI1NiIsInNoYTIyNCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   byteSwap: function() { return /* binding */ byteSwap; },\n/* harmony export */   byteSwap32: function() { return /* binding */ byteSwap32; },\n/* harmony export */   byteSwapIfBE: function() { return /* binding */ byteSwapIfBE; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotl: function() { return /* binding */ rotl; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n// Cast array to different type\nconst u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift)=>word << 32 - shift | word >>> shift;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;\nconst isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nconst byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async ()=>{};\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"utf8ToBytes expected string, got \" + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes() {\n    for(var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++){\n        arrays[_key] = arguments[_key];\n    }\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== \"[object Object]\") throw new Error(\"Options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */ function randomBytes() {\n    let bytesLength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes(bytesLength);\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsb0VBQW9FLEdBQ3BFLG9GQUFvRjtBQUNwRixzRUFBc0U7QUFDdEUsa0VBQWtFO0FBQ2xFLDhEQUE4RDtBQUM5RCwrREFBK0Q7QUFDL0QsMkVBQTJFO0FBQzdCO0FBQ1I7QUFDdEMsMENBQTBDO0FBQzFDLG9GQUFvRjtBQUM3RSxTQUFTRSxRQUFRQyxDQUFDO0lBQ3JCLE9BQU9BLGFBQWFDLGNBQWVDLFlBQVlDLE1BQU0sQ0FBQ0gsTUFBTUEsRUFBRUksV0FBVyxDQUFDQyxJQUFJLEtBQUs7QUFDdkY7QUFDQSwrQkFBK0I7QUFDeEIsTUFBTUMsS0FBSyxDQUFDQyxNQUFRLElBQUlOLFdBQVdNLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFRixJQUFJRyxVQUFVLEVBQUU7QUFDL0UsTUFBTUMsTUFBTSxDQUFDSixNQUFRLElBQUlLLFlBQVlMLElBQUlDLE1BQU0sRUFBRUQsSUFBSUUsVUFBVSxFQUFFSSxLQUFLQyxLQUFLLENBQUNQLElBQUlHLFVBQVUsR0FBRyxJQUFJO0FBQ3hHLHFCQUFxQjtBQUNkLE1BQU1LLGFBQWEsQ0FBQ1IsTUFBUSxJQUFJUyxTQUFTVCxJQUFJQyxNQUFNLEVBQUVELElBQUlFLFVBQVUsRUFBRUYsSUFBSUcsVUFBVSxFQUFFO0FBQzVGLCtEQUErRDtBQUN4RCxNQUFNTyxPQUFPLENBQUNDLE1BQU1DLFFBQVUsUUFBVSxLQUFLQSxRQUFXRCxTQUFTQyxNQUFPO0FBQy9FLDZEQUE2RDtBQUN0RCxNQUFNQyxPQUFPLENBQUNGLE1BQU1DLFFBQVUsUUFBU0EsUUFBVSxTQUFXLEtBQUtBLFVBQVksRUFBRztBQUNoRixNQUFNRSxPQUF1QixhQUFILEdBQUksS0FBTSxJQUFJcEIsV0FBVyxJQUFJ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QyxLQUFLUixPQUFTTSxTQUFTTixNQUFNUyxNQUFNLENBQUN0QixRQUFRcUIsTUFBTUUsTUFBTTtJQUN2RSxNQUFNQyxNQUFNTCxTQUFTLENBQUM7SUFDdEJDLE1BQU1LLFNBQVMsR0FBR0QsSUFBSUMsU0FBUztJQUMvQkwsTUFBTU0sUUFBUSxHQUFHRixJQUFJRSxRQUFRO0lBQzdCTixNQUFNTyxNQUFNLEdBQUcsQ0FBQ2QsT0FBU00sU0FBU047SUFDbEMsT0FBT087QUFDWDtBQUNBOztDQUVDLEdBQ00sU0FBU1U7UUFBWUMsY0FBQUEsaUVBQWM7SUFDdEMsSUFBSXhHLHdEQUFNQSxJQUFJLE9BQU9BLHdEQUFNQSxDQUFDeUcsZUFBZSxLQUFLLFlBQVk7UUFDeEQsT0FBT3pHLHdEQUFNQSxDQUFDeUcsZUFBZSxDQUFDLElBQUlyRyxXQUFXb0c7SUFDakQ7SUFDQSwrQkFBK0I7SUFDL0IsSUFBSXhHLHdEQUFNQSxJQUFJLE9BQU9BLHdEQUFNQSxDQUFDdUcsV0FBVyxLQUFLLFlBQVk7UUFDcEQsT0FBT3ZHLHdEQUFNQSxDQUFDdUcsV0FBVyxDQUFDQztJQUM5QjtJQUNBLE1BQU0sSUFBSXZELE1BQU07QUFDcEIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzP2YwMmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuaW1wb3J0IHsgYWJ5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIGV4cG9ydCB7IGlzQnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gV2UgY2FuJ3QgcmV1c2UgaXNCeXRlcyBmcm9tIF9hc3NlcnQsIGJlY2F1c2Ugc29tZWhvdyB0aGlzIGNhdXNlcyBodWdlIHBlcmYgaXNzdWVzXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RsID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xuZXhwb3J0IGNvbnN0IGlzTEUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG4vLyBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuLy8gQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtXG5leHBvcnQgY29uc3QgYnl0ZVN3YXBJZkJFID0gaXNMRSA/IChuKSA9PiBuIDogKG4pID0+IGJ5dGVTd2FwKG4pO1xuLy8gSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2Ygc3RyKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiY3J5cHRvIiwiYWJ5dGVzIiwiaXNCeXRlcyIsImEiLCJVaW50OEFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ1OCIsImFyciIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwidTMyIiwiVWludDMyQXJyYXkiLCJNYXRoIiwiZmxvb3IiLCJjcmVhdGVWaWV3IiwiRGF0YVZpZXciLCJyb3RyIiwid29yZCIsInNoaWZ0Iiwicm90bCIsImlzTEUiLCJieXRlU3dhcCIsImJ5dGVTd2FwSWZCRSIsIm4iLCJieXRlU3dhcDMyIiwiaSIsImxlbmd0aCIsImhleGVzIiwiQXJyYXkiLCJmcm9tIiwiXyIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJieXRlc1RvSGV4IiwiYnl0ZXMiLCJoZXgiLCJhc2NpaXMiLCJfMCIsIl85IiwiQSIsIkYiLCJmIiwiYXNjaWlUb0Jhc2UxNiIsImNoIiwiaGV4VG9CeXRlcyIsIkVycm9yIiwiaGwiLCJhbCIsImFycmF5IiwiYWkiLCJoaSIsIm4xIiwiY2hhckNvZGVBdCIsIm4yIiwidW5kZWZpbmVkIiwiY2hhciIsIm5leHRUaWNrIiwiYXN5bmNMb29wIiwiaXRlcnMiLCJ0aWNrIiwiY2IiLCJ0cyIsIkRhdGUiLCJub3ciLCJkaWZmIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInRvQnl0ZXMiLCJkYXRhIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJzdW0iLCJyZXMiLCJwYWQiLCJzZXQiLCJIYXNoIiwiY2xvbmUiLCJfY2xvbmVJbnRvIiwiY2hlY2tPcHRzIiwiZGVmYXVsdHMiLCJvcHRzIiwiY2FsbCIsIm1lcmdlZCIsIk9iamVjdCIsImFzc2lnbiIsIndyYXBDb25zdHJ1Y3RvciIsImhhc2hDb25zIiwiaGFzaEMiLCJtc2ciLCJ1cGRhdGUiLCJkaWdlc3QiLCJ0bXAiLCJvdXRwdXRMZW4iLCJibG9ja0xlbiIsImNyZWF0ZSIsIndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJyYW5kb21CeXRlcyIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/AccessList.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidStorageKeySizeError: function() { return /* binding */ InvalidStorageKeySizeError; },\n/* harmony export */   fromTupleList: function() { return /* binding */ fromTupleList; },\n/* harmony export */   toTupleList: function() { return /* binding */ toTupleList; }\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */ function fromTupleList(accessList) {\n    const list = [];\n    for(let i = 0; i < accessList.length; i++){\n        const [address, storageKeys] = accessList[i];\n        if (address) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, {\n            strict: false\n        });\n        list.push({\n            address: address,\n            storageKeys: storageKeys.map((key)=>_Hash_js__WEBPACK_IMPORTED_MODULE_1__.validate(key) ? key : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.trimLeft(key))\n        });\n    }\n    return list;\n}\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */ function toTupleList(accessList) {\n    if (!accessList || accessList.length === 0) return [];\n    const tuple = [];\n    for (const { address, storageKeys } of accessList){\n        for(let j = 0; j < storageKeys.length; j++)if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKeys[j]) !== 32) throw new InvalidStorageKeySizeError({\n            storageKey: storageKeys[j]\n        });\n        if (address) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, {\n            strict: false\n        });\n        tuple.push([\n            address,\n            storageKeys\n        ]);\n    }\n    return tuple;\n}\n/** Thrown when the size of a storage key is invalid. */ class InvalidStorageKeySizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ storageKey }){\n        super('Size for storage key \"'.concat(storageKey, '\" is invalid. Expected 32 bytes. Got ').concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKey), \" bytes.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"AccessList.InvalidStorageKeySizeError\"\n        });\n    }\n} //# sourceMappingURL=AccessList.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWNjZXNzTGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdDO0FBQ0Y7QUFDSjtBQUNGO0FBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZCQyxHQUNNLFNBQVNJLGNBQWNDLFVBQVU7SUFDcEMsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFdBQVdHLE1BQU0sRUFBRUQsSUFBSztRQUN4QyxNQUFNLENBQUNFLFNBQVNDLFlBQVksR0FBR0wsVUFBVSxDQUFDRSxFQUFFO1FBQzVDLElBQUlFLFNBQ0FULCtDQUFjLENBQUNTLFNBQVM7WUFBRUcsUUFBUTtRQUFNO1FBQzVDTixLQUFLTyxJQUFJLENBQUM7WUFDTkosU0FBU0E7WUFDVEMsYUFBYUEsWUFBWUksR0FBRyxDQUFDLENBQUNDLE1BQVFiLDhDQUFhLENBQUNhLE9BQU9BLE1BQU1aLDZDQUFZLENBQUNZO1FBQ2xGO0lBQ0o7SUFDQSxPQUFPVDtBQUNYO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E0QkMsR0FDTSxTQUFTWSxZQUFZYixVQUFVO0lBQ2xDLElBQUksQ0FBQ0EsY0FBY0EsV0FBV0csTUFBTSxLQUFLLEdBQ3JDLE9BQU8sRUFBRTtJQUNiLE1BQU1XLFFBQVEsRUFBRTtJQUNoQixLQUFLLE1BQU0sRUFBRVYsT0FBTyxFQUFFQyxXQUFXLEVBQUUsSUFBSUwsV0FBWTtRQUMvQyxJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSVYsWUFBWUYsTUFBTSxFQUFFWSxJQUNwQyxJQUFJakIseUNBQVEsQ0FBQ08sV0FBVyxDQUFDVSxFQUFFLE1BQU0sSUFDN0IsTUFBTSxJQUFJRSwyQkFBMkI7WUFDakNDLFlBQVliLFdBQVcsQ0FBQ1UsRUFBRTtRQUM5QjtRQUNSLElBQUlYLFNBQ0FULCtDQUFjLENBQUNTLFNBQVM7WUFBRUcsUUFBUTtRQUFNO1FBQzVDTyxNQUFNTixJQUFJLENBQUM7WUFBQ0o7WUFBU0M7U0FBWTtJQUNyQztJQUNBLE9BQU9TO0FBQ1g7QUFDQSxzREFBc0QsR0FDL0MsTUFBTUcsbUNBQW1DckIsaURBQWdCO0lBQzVEd0IsWUFBWSxFQUFFRixVQUFVLEVBQUUsQ0FBRTtRQUN4QixLQUFLLENBQUMseUJBQTJFcEIsT0FBbERvQixZQUFXLHlDQUE0RCxPQUFyQnBCLHlDQUFRLENBQUNvQixhQUFZO1FBQ3RHRyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BY2Nlc3NMaXN0LmpzPzJkYWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBBY2Nlc3MgTGlzdCB0dXBsZXMgaW50byBhIG9iamVjdC1mb3JtYXR0ZWQgbGlzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC5mcm9tVHVwbGVMaXN0KFtcbiAqICAgW1xuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgIFtcbiAqICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgICAgJzB4NjBmZGQyOWZmOTEyY2U4ODBjZDNlZGFmOWY5MzJkYzYxZDNkYWU4MjNlYTc3ZTAzMjNmOTRhZGI5ZjZhNzJmZScsXG4gKiAgICAgXSxcbiAqICAgXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgICBzdG9yYWdlS2V5czogW1xuICogLy8gQGxvZzogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAvLyBAbG9nOiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqIC8vIEBsb2c6ICAgICBdLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjY2Vzc0xpc3QgLSBMaXN0IG9mIHR1cGxlcy5cbiAqIEByZXR1cm5zIEFjY2VzcyBsaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjZXNzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBbYWRkcmVzcywgc3RvcmFnZUtleXNdID0gYWNjZXNzTGlzdFtpXTtcbiAgICAgICAgaWYgKGFkZHJlc3MpXG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoa2V5KSA9PiBIYXNoLnZhbGlkYXRlKGtleSkgPyBrZXkgOiBIZXgudHJpbUxlZnQoa2V5KSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBzdHJ1Y3R1cmVkIEFjY2VzcyBMaXN0IGludG8gYSBsaXN0IG9mIHR1cGxlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC50b1R1cGxlTGlzdChbXG4gKiAgIHtcbiAqICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICBzdG9yYWdlS2V5czogW1xuICogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJ10sXG4gKiAgIH0sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICBbXG4gKiAvLyBAbG9nOiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgICAgW1xuICogLy8gQGxvZzogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAvLyBAbG9nOiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqIC8vIEBsb2c6ICAgICBdLFxuICogLy8gQGxvZzogICBdLFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjY2Vzc0xpc3QgLSBBY2Nlc3MgbGlzdC5cbiAqIEByZXR1cm5zIExpc3Qgb2YgdHVwbGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZUxpc3QoYWNjZXNzTGlzdCkge1xuICAgIGlmICghYWNjZXNzTGlzdCB8fCBhY2Nlc3NMaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHR1cGxlID0gW107XG4gICAgZm9yIChjb25zdCB7IGFkZHJlc3MsIHN0b3JhZ2VLZXlzIH0gb2YgYWNjZXNzTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JhZ2VLZXlzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgaWYgKEhleC5zaXplKHN0b3JhZ2VLZXlzW2pdKSAhPT0gMzIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZUtleTogc3RvcmFnZUtleXNbal0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChhZGRyZXNzKVxuICAgICAgICAgICAgQWRkcmVzcy5hc3NlcnQoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgICAgICB0dXBsZS5wdXNoKFthZGRyZXNzLCBzdG9yYWdlS2V5c10pO1xuICAgIH1cbiAgICByZXR1cm4gdHVwbGU7XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpemUgb2YgYSBzdG9yYWdlIGtleSBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzdG9yYWdlS2V5IH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgZm9yIHN0b3JhZ2Uga2V5IFwiJHtzdG9yYWdlS2V5fVwiIGlzIGludmFsaWQuIEV4cGVjdGVkIDMyIGJ5dGVzLiBHb3QgJHtIZXguc2l6ZShzdG9yYWdlS2V5KX0gYnl0ZXMuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBY2Nlc3NMaXN0LkludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2Nlc3NMaXN0LmpzLm1hcCJdLCJuYW1lcyI6WyJBZGRyZXNzIiwiRXJyb3JzIiwiSGFzaCIsIkhleCIsImZyb21UdXBsZUxpc3QiLCJhY2Nlc3NMaXN0IiwibGlzdCIsImkiLCJsZW5ndGgiLCJhZGRyZXNzIiwic3RvcmFnZUtleXMiLCJhc3NlcnQiLCJzdHJpY3QiLCJwdXNoIiwibWFwIiwia2V5IiwidmFsaWRhdGUiLCJ0cmltTGVmdCIsInRvVHVwbGVMaXN0IiwidHVwbGUiLCJqIiwic2l6ZSIsIkludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yIiwic3RvcmFnZUtleSIsIkJhc2VFcnJvciIsImNvbnN0cnVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/Authorization.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromRpc: function() { return /* binding */ fromRpc; },\n/* harmony export */   fromRpcList: function() { return /* binding */ fromRpcList; },\n/* harmony export */   fromTuple: function() { return /* binding */ fromTuple; },\n/* harmony export */   fromTupleList: function() { return /* binding */ fromTupleList; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   toRpcList: function() { return /* binding */ toRpcList; },\n/* harmony export */   toTuple: function() { return /* binding */ toTuple; },\n/* harmony export */   toTupleList: function() { return /* binding */ toTupleList; }\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */ function from(authorization) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (typeof authorization.chainId === \"string\") return fromRpc(authorization);\n    return {\n        ...authorization,\n        ...options.signature\n    };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */ function fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */ function fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */ function fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    const signature = yParity && r && s ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([\n        yParity,\n        r,\n        s\n    ]) : undefined;\n    return from({\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature\n    });\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */ function fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */ function getSignPayload(authorization) {\n    return hash(authorization);\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */ function hash(authorization) {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(\"0x05\", _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */ function toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature)\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */ function toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */ function toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : \"0x\",\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : \"0x\",\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */ function toTupleList(list) {\n    if (!list || list.length === 0) return [];\n    const tupleList = [];\n    for (const authorization of list)tupleList.push(toTuple(authorization));\n    return tupleList;\n} //# sourceMappingURL=Authorization.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQXV0aG9yaXphdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDRjtBQUNBO0FBQ1k7QUFDNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTBDQyxHQUNNLFNBQVNJLEtBQUtDLGFBQWE7UUFBRUMsVUFBQUEsaUVBQVUsQ0FBQztJQUMzQyxJQUFJLE9BQU9ELGNBQWNFLE9BQU8sS0FBSyxVQUNqQyxPQUFPQyxRQUFRSDtJQUNuQixPQUFPO1FBQUUsR0FBR0EsYUFBYTtRQUFFLEdBQUdDLFFBQVFHLFNBQVM7SUFBQztBQUNwRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sU0FBU0QsUUFBUUgsYUFBYTtJQUNqQyxNQUFNLEVBQUVLLE9BQU8sRUFBRUgsT0FBTyxFQUFFSSxLQUFLLEVBQUUsR0FBR047SUFDcEMsTUFBTUksWUFBWU4sa0RBQWlCLENBQUNFO0lBQ3BDLE9BQU87UUFDSEs7UUFDQUgsU0FBU00sT0FBT047UUFDaEJJLE9BQU9HLE9BQU9IO1FBQ2QsR0FBR0YsU0FBUztJQUNoQjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTTSxZQUFZQyxpQkFBaUI7SUFDekMsT0FBT0Esa0JBQWtCQyxHQUFHLENBQUNUO0FBQ2pDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQTZDQyxHQUNNLFNBQVNVLFVBQVVDLEtBQUs7SUFDM0IsTUFBTSxDQUFDWixTQUFTRyxTQUFTQyxPQUFPUyxTQUFTQyxHQUFHQyxFQUFFLEdBQUdIO0lBQ2pELE1BQU1WLFlBQVlXLFdBQVdDLEtBQUtDLElBQUluQixvREFBbUIsQ0FBQztRQUFDaUI7UUFBU0M7UUFBR0M7S0FBRSxJQUFJQztJQUM3RSxPQUFPbkIsS0FBSztRQUNSTTtRQUNBSCxTQUFTTSxPQUFPTjtRQUNoQkksT0FBT0csT0FBT0g7UUFDZCxHQUFHRixTQUFTO0lBQ2hCO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBeURDLEdBQ00sU0FBU2UsY0FBY0MsU0FBUztJQUNuQyxNQUFNQyxPQUFPLEVBQUU7SUFDZixLQUFLLE1BQU1QLFNBQVNNLFVBQ2hCQyxLQUFLQyxJQUFJLENBQUNULFVBQVVDO0lBQ3hCLE9BQU9PO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQkMsR0FDTSxTQUFTRSxlQUFldkIsYUFBYTtJQUN4QyxPQUFPd0IsS0FBS3hCO0FBQ2hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVN3QixLQUFLeEIsYUFBYTtJQUM5QixPQUFPTCwrQ0FBYyxDQUFDQywyQ0FBVSxDQUFDLFFBQVFDLDRDQUFXLENBQUMrQixRQUFRNUI7QUFDakU7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVM2QixNQUFNN0IsYUFBYTtJQUMvQixNQUFNLEVBQUVLLE9BQU8sRUFBRUgsT0FBTyxFQUFFSSxLQUFLLEVBQUUsR0FBR0YsV0FBVyxHQUFHSjtJQUNsRCxPQUFPO1FBQ0hLO1FBQ0FILFNBQVNOLCtDQUFjLENBQUNNO1FBQ3hCSSxPQUFPViwrQ0FBYyxDQUFDVTtRQUN0QixHQUFHUixnREFBZSxDQUFDTSxVQUFVO0lBQ2pDO0FBQ0o7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVMyQixVQUFVcEIsaUJBQWlCO0lBQ3ZDLE9BQU9BLGtCQUFrQkMsR0FBRyxDQUFDaUI7QUFDakM7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0F1QkMsR0FDTSxTQUFTRCxRQUFRNUIsYUFBYTtJQUNqQyxNQUFNLEVBQUVLLE9BQU8sRUFBRUgsT0FBTyxFQUFFSSxLQUFLLEVBQUUsR0FBR047SUFDcEMsTUFBTUksWUFBWU4sa0RBQWlCLENBQUNFO0lBQ3BDLE9BQU87UUFDSEUsVUFBVU4sK0NBQWMsQ0FBQ00sV0FBVztRQUNwQ0c7UUFDQUMsUUFBUVYsK0NBQWMsQ0FBQ1UsU0FBUztXQUM1QkYsWUFBWU4sa0RBQWlCLENBQUNNLGFBQWEsRUFBRTtLQUNwRDtBQUNMO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUNDLEdBQ00sU0FBUzRCLFlBQVlYLElBQUk7SUFDNUIsSUFBSSxDQUFDQSxRQUFRQSxLQUFLWSxNQUFNLEtBQUssR0FDekIsT0FBTyxFQUFFO0lBQ2IsTUFBTWIsWUFBWSxFQUFFO0lBQ3BCLEtBQUssTUFBTXBCLGlCQUFpQnFCLEtBQ3hCRCxVQUFVRSxJQUFJLENBQUNNLFFBQVE1QjtJQUMzQixPQUFPb0I7QUFDWCxFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0F1dGhvcml6YXRpb24uanM/MmZiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4vUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIG9iamVjdCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIEFuIEF1dGhvcml6YXRpb24gY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGluIG9iamVjdCBmb3JtYXQuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGNhbiBiZSBhdHRhY2hlZCB3aXRoIHRoZSBgc2lnbmF0dXJlYCBvcHRpb24uIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBzaWduaW5nXG4gKiBhbiBBdXRob3JpemF0aW9uIHdpdGgge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA0MG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uLmZyb20oYXV0aG9yaXphdGlvbiwgeyBzaWduYXR1cmUgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBdXRob3JpemF0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgYXV0aG9yaXphdGlvbi5jaGFpbklkID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21ScGMoYXV0aG9yaXphdGlvbik7XG4gICAgcmV0dXJuIHsgLi4uYXV0aG9yaXphdGlvbiwgLi4ub3B0aW9ucy5zaWduYXR1cmUgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uUnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUgUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uLlxuICogQHJldHVybnMgQSBzaWduZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IEJpZ0ludChub25jZSksXG4gICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVJwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIFRoZSBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24gbGlzdC5cbiAqIEByZXR1cm5zIEEgc2lnbmVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKGZyb21ScGMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5UdXBsZX0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlKFtcbiAqICAgJzB4MScsXG4gKiAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICAnMHgzJ1xuICogXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiAzblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXBwZW5kIGEgU2lnbmF0dXJlIHR1cGxlIHRvIHRoZSBlbmQgb2YgYW4gQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MycsXG4gKiAgICcweDEnLFxuICogICAnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyxcbiAqICAgJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcsXG4gKiBdKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDNuXG4gKiAvLyBAbG9nOiAgIHI6IEJpZ0ludCgnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyksXG4gKiAvLyBAbG9nOiAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGUgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbY2hhaW5JZCwgYWRkcmVzcywgbm9uY2UsIHlQYXJpdHksIHIsIHNdID0gdHVwbGU7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0geVBhcml0eSAmJiByICYmIHMgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZyb20oe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBCaWdJbnQobm9uY2UpLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJ10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhcHBlbmQgYSBTaWduYXR1cmUgdHVwbGUgdG8gdGhlIGVuZCBvZiBhbiBBdXRob3JpemF0aW9uIHR1cGxlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJywgJzB4MScsICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLCAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0J10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0JywgJzB4MScsICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLCAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGVMaXN0IC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGxpc3QuXG4gKiBAcmV0dXJucyBBbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZUxpc3QodHVwbGVMaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgdHVwbGUgb2YgdHVwbGVMaXN0KVxuICAgICAgICBsaXN0LnB1c2goZnJvbVR1cGxlKHR1cGxlKSk7XG4gICAgcmV0dXJuIGxpc3Q7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzaWduIHBheWxvYWQgZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IGluIFtFSVAtNzcwMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMik6IGBrZWNjYWsyNTYoJzB4MDUnIHx8IHJscChbY2hhaW5faWQsIGFkZHJlc3MsIG5vbmNlXSkpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGNvbXB1dGluZyB0aGUgc2lnbiBwYXlsb2FkIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS4gVGhpcyBwYXlsb2FkXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8gc2lnbmluZyBmdW5jdGlvbnMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZCxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSB7XG4gICAgcmV0dXJuIGhhc2goYXV0aG9yaXphdGlvbik7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSBpbiBbRUlQLTc3MDIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpOiBga2VjY2FrMjU2KCcweDA1JyB8fCBybHAoW2NoYWluX2lkLCBhZGRyZXNzLCBub25jZV0pKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gQXV0aG9yaXphdGlvbi5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24pIHtcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmNvbmNhdCgnMHgwNScsIFJscC5mcm9tSGV4KHRvVHVwbGUoYXV0aG9yaXphdGlvbikpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24udG9ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSwgLi4uc2lnbmF0dXJlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogSGV4LmZyb21OdW1iZXIobm9uY2UpLFxuICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAxbixcbiAqICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgIHlQYXJpdHk6IDAsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIEFuIEF1dGhvcml6YXRpb24gTGlzdC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbiBMaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcCh0b1JwYyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjaGFpbklkID8gSGV4LmZyb21OdW1iZXIoY2hhaW5JZCkgOiAnMHgnLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9UdXBsZShzaWduYXR1cmUpIDogW10pLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl8xID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl8yID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDMsXG4gKiAgIG5vbmNlOiAyMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlTGlzdChbYXV0aG9yaXphdGlvbl8xLCBhdXRob3JpemF0aW9uXzJdKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGlzdCAtIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICogQHJldHVybnMgQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGVMaXN0KGxpc3QpIHtcbiAgICBpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0dXBsZUxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgbGlzdClcbiAgICAgICAgdHVwbGVMaXN0LnB1c2godG9UdXBsZShhdXRob3JpemF0aW9uKSk7XG4gICAgcmV0dXJuIHR1cGxlTGlzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbIkhhc2giLCJIZXgiLCJSbHAiLCJTaWduYXR1cmUiLCJmcm9tIiwiYXV0aG9yaXphdGlvbiIsIm9wdGlvbnMiLCJjaGFpbklkIiwiZnJvbVJwYyIsInNpZ25hdHVyZSIsImFkZHJlc3MiLCJub25jZSIsImV4dHJhY3QiLCJOdW1iZXIiLCJCaWdJbnQiLCJmcm9tUnBjTGlzdCIsImF1dGhvcml6YXRpb25MaXN0IiwibWFwIiwiZnJvbVR1cGxlIiwidHVwbGUiLCJ5UGFyaXR5IiwiciIsInMiLCJ1bmRlZmluZWQiLCJmcm9tVHVwbGVMaXN0IiwidHVwbGVMaXN0IiwibGlzdCIsInB1c2giLCJnZXRTaWduUGF5bG9hZCIsImhhc2giLCJrZWNjYWsyNTYiLCJjb25jYXQiLCJmcm9tSGV4IiwidG9UdXBsZSIsInRvUnBjIiwiZnJvbU51bWJlciIsInRvUnBjTGlzdCIsInRvVHVwbGVMaXN0IiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Rlp.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: function() { return /* binding */ decodeRlpCursor; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromBytes: function() { return /* binding */ fromBytes; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   readLength: function() { return /* binding */ readLength; },\n/* harmony export */   readList: function() { return /* binding */ readList; },\n/* harmony export */   to: function() { return /* binding */ to; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; }\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */ function toBytes(value) {\n    return to(value, \"Bytes\");\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */ function toHex(value) {\n    return to(value, \"Hex\");\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */ function to(value, to) {\n    const to_ = to !== null && to !== void 0 ? to : typeof value === \"string\" ? \"Hex\" : \"Bytes\";\n    const bytes = (()=>{\n        if (typeof value === \"string\") {\n            if (value.length > 3 && value.length % 2 !== 0) throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */ /** @internal */ function decodeRlpCursor(cursor) {\n    let to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"Hex\";\n    if (cursor.bytes.length === 0) return to === \"Hex\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes;\n    const prefix = cursor.readByte();\n    if (prefix < 0x80) cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return to === \"Hex\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes;\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */ function readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80) return 1;\n    if (prefix <= offset + 55) return prefix - offset;\n    if (prefix === offset + 55 + 1) return cursor.readUint8();\n    if (prefix === offset + 55 + 2) return cursor.readUint16();\n    if (prefix === offset + 55 + 3) return cursor.readUint24();\n    if (prefix === offset + 55 + 4) return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(\"Invalid RLP prefix\");\n}\n/** @internal */ function readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while(cursor.position - position < length)value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === \"Hex\") return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function fromBytes(bytes) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { as = \"Bytes\" } = options;\n    return from(bytes, {\n        as\n    });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */ function fromHex(hex) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { as = \"Hex\" } = options;\n    return from(hex, {\n        as\n    });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes)) return getEncodableList(bytes.map((x)=>getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x)=>acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (()=>{\n        if (bodyLength <= 55) return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            } else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);\n                else cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list){\n                encode(cursor);\n            }\n        }\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === \"string\" ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (()=>{\n        if (bytes.length === 1 && bytes[0] < 0x80) return 1;\n        if (bytes.length <= 55) return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode (cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            } else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            } else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);\n                else cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        }\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length < 2 ** 8) return 1;\n    if (length < 2 ** 16) return 2;\n    if (length < 2 ** 24) return 3;\n    if (length < 2 ** 32) return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(\"Length is too large.\");\n} //# sourceMappingURL=Rlp.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNOO0FBQ2U7QUFDL0M7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0ksUUFBUUMsS0FBSztJQUN6QixPQUFPQyxHQUFHRCxPQUFPO0FBQ3JCO0FBQ0E7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU0UsTUFBTUYsS0FBSztJQUN2QixPQUFPQyxHQUFHRCxPQUFPO0FBQ3JCO0FBQ0EsaUZBQWlGO0FBQ2pGLFdBQVc7QUFDWCxpRkFBaUY7QUFDakYsY0FBYyxHQUNQLFNBQVNDLEdBQUdELEtBQUssRUFBRUMsRUFBRTtJQUN4QixNQUFNRSxNQUFNRixlQUFBQSxnQkFBQUEsS0FBTyxPQUFPRCxVQUFVLFdBQVcsUUFBUTtJQUN2RCxNQUFNSSxRQUFRLENBQUM7UUFDWCxJQUFJLE9BQU9KLFVBQVUsVUFBVTtZQUMzQixJQUFJQSxNQUFNSyxNQUFNLEdBQUcsS0FBS0wsTUFBTUssTUFBTSxHQUFHLE1BQU0sR0FDekMsTUFBTSxJQUFJUix1REFBc0IsQ0FBQ0c7WUFDckMsT0FBT0wsOENBQWEsQ0FBQ0s7UUFDekI7UUFDQSxPQUFPQTtJQUNYO0lBQ0EsTUFBTVEsU0FBU1YsdURBQWEsQ0FBQ00sT0FBTztRQUNoQ00sb0JBQW9CQyxPQUFPQyxpQkFBaUI7SUFDaEQ7SUFDQSxNQUFNQyxTQUFTQyxnQkFBZ0JOLFFBQVFMO0lBQ3ZDLE9BQU9VO0FBQ1g7QUFDQSxjQUFjLEdBQ2QsY0FBYyxHQUNQLFNBQVNDLGdCQUFnQk4sTUFBTTtRQUFFUCxLQUFBQSxpRUFBSztJQUN6QyxJQUFJTyxPQUFPSixLQUFLLENBQUNDLE1BQU0sS0FBSyxHQUN4QixPQUFRSixPQUFPLFFBQVFKLDhDQUFhLENBQUNXLE9BQU9KLEtBQUssSUFBSUksT0FBT0osS0FBSztJQUNyRSxNQUFNWSxTQUFTUixPQUFPUyxRQUFRO0lBQzlC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QU07Z0JBQ25DRyxPQUFPaUQsU0FBUyxDQUFDckQ7WUFDckIsT0FDSztnQkFDREksT0FBTzBDLFFBQVEsQ0FBQyxPQUFPLEtBQUtNO2dCQUM1QixJQUFJQSxzQkFBc0IsR0FDdEJoRCxPQUFPMkMsU0FBUyxDQUFDL0MsTUFBTUMsTUFBTTtxQkFDNUIsSUFBSW1ELHNCQUFzQixHQUMzQmhELE9BQU80QyxVQUFVLENBQUNoRCxNQUFNQyxNQUFNO3FCQUM3QixJQUFJbUQsc0JBQXNCLEdBQzNCaEQsT0FBTzZDLFVBQVUsQ0FBQ2pELE1BQU1DLE1BQU07cUJBRTlCRyxPQUFPOEMsVUFBVSxDQUFDbEQsTUFBTUMsTUFBTTtnQkFDbENHLE9BQU9pRCxTQUFTLENBQUNyRDtZQUNyQjtRQUNKO0lBQ0o7QUFDSjtBQUNBLFNBQVM2QyxnQkFBZ0I1QyxNQUFNO0lBQzNCLElBQUlBLFNBQVMsS0FBSyxHQUNkLE9BQU87SUFDWCxJQUFJQSxTQUFTLEtBQUssSUFDZCxPQUFPO0lBQ1gsSUFBSUEsU0FBUyxLQUFLLElBQ2QsT0FBTztJQUNYLElBQUlBLFNBQVMsS0FBSyxJQUNkLE9BQU87SUFDWCxNQUFNLElBQUlULGlEQUFnQixDQUFDO0FBQy9CLEVBQ0EsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzPzg2YzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEN1cnNvciBmcm9tICcuL2ludGVybmFsL2N1cnNvci5qcyc7XG4vKipcbiAqIERlY29kZXMgYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICogUmxwLnRvQnl0ZXMoJzB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIFVpbnQ4QXJyYXkoWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvKHZhbHVlLCAnQnl0ZXMnKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqIFJscC50b0hleCgnMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdG8odmFsdWUsICdIZXgnKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvKHZhbHVlLCB0bykge1xuICAgIGNvbnN0IHRvXyA9IHRvID8/ICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnKTtcbiAgICBjb25zdCBieXRlcyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMyAmJiB2YWx1ZS5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBIZXguSW52YWxpZExlbmd0aEVycm9yKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkoKTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzLCB7XG4gICAgICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvXyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0byA9ICdIZXgnKSB7XG4gICAgaWYgKGN1cnNvci5ieXRlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAodG8gPT09ICdIZXgnID8gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpIDogY3Vyc29yLmJ5dGVzKTtcbiAgICBjb25zdCBwcmVmaXggPSBjdXJzb3IucmVhZEJ5dGUoKTtcbiAgICBpZiAocHJlZml4IDwgMHg4MClcbiAgICAgICAgY3Vyc29yLmRlY3JlbWVudFBvc2l0aW9uKDEpO1xuICAgIC8vIGJ5dGVzXG4gICAgaWYgKHByZWZpeCA8IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHg4MCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoYnl0ZXMpIDogYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBsaXN0XG4gICAgY29uc3QgbGVuZ3RoID0gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgMHhjMCk7XG4gICAgcmV0dXJuIHJlYWRMaXN0KGN1cnNvciwgbGVuZ3RoLCB0byk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExlbmd0aChjdXJzb3IsIHByZWZpeCwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA9PT0gMHg4MCAmJiBwcmVmaXggPCAweDgwKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAocHJlZml4IDw9IG9mZnNldCArIDU1KVxuICAgICAgICByZXR1cm4gcHJlZml4IC0gb2Zmc2V0O1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMSlcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDgoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDIpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQxNigpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgMylcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDI0KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyA0KVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MzIoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignSW52YWxpZCBSTFAgcHJlZml4Jyk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZExpc3QoY3Vyc29yLCBsZW5ndGgsIHRvKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBjdXJzb3IucG9zaXRpb247XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICB3aGlsZSAoY3Vyc29yLnBvc2l0aW9uIC0gcG9zaXRpb24gPCBsZW5ndGgpXG4gICAgICAgIHZhbHVlLnB1c2goZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8pKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb20oJzB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcsIHsgYXM6ICdIZXgnIH0pXG4gKiAvLyBAbG9nOiAweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICpcbiAqIFJscC5mcm9tKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSwgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbmNvZGFibGUgPSBnZXRFbmNvZGFibGUodmFsdWUpO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUobmV3IFVpbnQ4QXJyYXkoZW5jb2RhYmxlLmxlbmd0aCkpO1xuICAgIGVuY29kYWJsZS5lbmNvZGUoY3Vyc29yKTtcbiAgICBpZiAoYXMgPT09ICdIZXgnKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhjdXJzb3IuYnl0ZXMpO1xuICAgIHJldHVybiBjdXJzb3IuYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzEzOSwgMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTEsICAzMiwgMTE5LCAxMTEsIDExNCwgMTA4LCAxMDBdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGJ5dGVzLCB7IGFzIH0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tSGV4KCcweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnKVxuICogLy8gQGxvZzogMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBSTFAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdIZXgnIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBmcm9tKGhleCwgeyBhcyB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW50ZXJuYWxcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlKGJ5dGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYnl0ZXMpKVxuICAgICAgICByZXR1cm4gZ2V0RW5jb2RhYmxlTGlzdChieXRlcy5tYXAoKHgpID0+IGdldEVuY29kYWJsZSh4KSkpO1xuICAgIHJldHVybiBnZXRFbmNvZGFibGVCeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiBnZXRFbmNvZGFibGVMaXN0KGxpc3QpIHtcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gbGlzdC5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjICsgeC5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHNpemVPZkJvZHlMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYm9keUxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJvZHlMZW5ndGggPD0gNTUpXG4gICAgICAgICAgICByZXR1cm4gMSArIGJvZHlMZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQm9keUxlbmd0aCArIGJvZHlMZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4YzAgKyBib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgNTUgKyBzaXplT2ZCb2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCb2R5TGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJvZHlMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGVuY29kZSB9IG9mIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGUoY3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXNPckhleCkge1xuICAgIGNvbnN0IGJ5dGVzID0gdHlwZW9mIGJ5dGVzT3JIZXggPT09ICdzdHJpbmcnID8gQnl0ZXMuZnJvbUhleChieXRlc09ySGV4KSA6IGJ5dGVzT3JIZXg7XG4gICAgY29uc3Qgc2l6ZU9mQnl0ZXNMZW5ndGggPSBnZXRTaXplT2ZMZW5ndGgoYnl0ZXMubGVuZ3RoKTtcbiAgICBjb25zdCBsZW5ndGggPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBieXRlcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiAxICsgc2l6ZU9mQnl0ZXNMZW5ndGggKyBieXRlcy5sZW5ndGg7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGgsXG4gICAgICAgIGVuY29kZShjdXJzb3IpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPT09IDEgJiYgYnl0ZXNbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHg4MCArIDU1ICsgc2l6ZU9mQnl0ZXNMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50OChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAyKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQxNihieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNpemVPZkJ5dGVzTGVuZ3RoID09PSAzKVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQyNChieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2l6ZU9mTGVuZ3RoKGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPCAyICoqIDgpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChsZW5ndGggPCAyICoqIDE2KVxuICAgICAgICByZXR1cm4gMjtcbiAgICBpZiAobGVuZ3RoIDwgMiAqKiAyNClcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgaWYgKGxlbmd0aCA8IDIgKiogMzIpXG4gICAgICAgIHJldHVybiA0O1xuICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdMZW5ndGggaXMgdG9vIGxhcmdlLicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmxwLmpzLm1hcCJdLCJuYW1lcyI6WyJCeXRlcyIsIkVycm9ycyIsIkhleCIsIkN1cnNvciIsInRvQnl0ZXMiLCJ2YWx1ZSIsInRvIiwidG9IZXgiLCJ0b18iLCJieXRlcyIsImxlbmd0aCIsIkludmFsaWRMZW5ndGhFcnJvciIsImZyb21IZXgiLCJjdXJzb3IiLCJjcmVhdGUiLCJyZWN1cnNpdmVSZWFkTGltaXQiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsInJlc3VsdCIsImRlY29kZVJscEN1cnNvciIsImZyb21CeXRlcyIsInByZWZpeCIsInJlYWRCeXRlIiwiZGVjcmVtZW50UG9zaXRpb24iLCJyZWFkTGVuZ3RoIiwicmVhZEJ5dGVzIiwicmVhZExpc3QiLCJvZmZzZXQiLCJyZWFkVWludDgiLCJyZWFkVWludDE2IiwicmVhZFVpbnQyNCIsInJlYWRVaW50MzIiLCJCYXNlRXJyb3IiLCJwb3NpdGlvbiIsInB1c2giLCJmcm9tIiwib3B0aW9ucyIsImFzIiwiZW5jb2RhYmxlIiwiZ2V0RW5jb2RhYmxlIiwiVWludDhBcnJheSIsImVuY29kZSIsImhleCIsIkFycmF5IiwiaXNBcnJheSIsImdldEVuY29kYWJsZUxpc3QiLCJtYXAiLCJ4IiwiZ2V0RW5jb2RhYmxlQnl0ZXMiLCJsaXN0IiwiYm9keUxlbmd0aCIsInJlZHVjZSIsImFjYyIsInNpemVPZkJvZHlMZW5ndGgiLCJnZXRTaXplT2ZMZW5ndGgiLCJwdXNoQnl0ZSIsInB1c2hVaW50OCIsInB1c2hVaW50MTYiLCJwdXNoVWludDI0IiwicHVzaFVpbnQzMiIsImJ5dGVzT3JIZXgiLCJzaXplT2ZCeXRlc0xlbmd0aCIsInB1c2hCeXRlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: function() { return /* binding */ InvalidRError; },\n/* harmony export */   InvalidSError: function() { return /* binding */ InvalidSError; },\n/* harmony export */   InvalidSerializedSizeError: function() { return /* binding */ InvalidSerializedSizeError; },\n/* harmony export */   InvalidVError: function() { return /* binding */ InvalidVError; },\n/* harmony export */   InvalidYParityError: function() { return /* binding */ InvalidYParityError; },\n/* harmony export */   MissingPropertiesError: function() { return /* binding */ MissingPropertiesError; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   extract: function() { return /* binding */ extract; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromBytes: function() { return /* binding */ fromBytes; },\n/* harmony export */   fromDerBytes: function() { return /* binding */ fromDerBytes; },\n/* harmony export */   fromDerHex: function() { return /* binding */ fromDerHex; },\n/* harmony export */   fromHex: function() { return /* binding */ fromHex; },\n/* harmony export */   fromLegacy: function() { return /* binding */ fromLegacy; },\n/* harmony export */   fromRpc: function() { return /* binding */ fromRpc; },\n/* harmony export */   fromTuple: function() { return /* binding */ fromTuple; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   toDerBytes: function() { return /* binding */ toDerBytes; },\n/* harmony export */   toDerHex: function() { return /* binding */ toDerHex; },\n/* harmony export */   toHex: function() { return /* binding */ toHex; },\n/* harmony export */   toLegacy: function() { return /* binding */ toLegacy; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   toTuple: function() { return /* binding */ toTuple; },\n/* harmony export */   vToYParity: function() { return /* binding */ vToYParity; },\n/* harmony export */   validate: function() { return /* binding */ validate; },\n/* harmony export */   yParityToV: function() { return /* binding */ yParityToV; }\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */ function assert(signature) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { recovered } = options;\n    if (typeof signature.r === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (typeof signature.s === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (recovered && typeof signature.yParity === \"undefined\") throw new MissingPropertiesError({\n        signature\n    });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidRError({\n        value: signature.r\n    });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256) throw new InvalidSError({\n        value: signature.s\n    });\n    if (typeof signature.yParity === \"number\" && signature.yParity !== 0 && signature.yParity !== 1) throw new InvalidYParityError({\n        value: signature.yParity\n    });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */ function fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132) throw new InvalidSerializedSizeError({\n        signature\n    });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (()=>{\n        const yParity = Number(\"0x\".concat(signature.slice(130)));\n        if (Number.isNaN(yParity)) return undefined;\n        try {\n            return vToYParity(yParity);\n        } catch (e) {\n            throw new InvalidYParityError({\n                value: yParity\n            });\n        }\n    })();\n    if (typeof yParity === \"undefined\") return {\n        r,\n        s\n    };\n    return {\n        r,\n        s,\n        yParity\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */ function extract(value) {\n    if (typeof value.r === \"undefined\") return undefined;\n    if (typeof value.s === \"undefined\") return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */ function from(signature) {\n    const signature_ = (()=>{\n        if (typeof signature === \"string\") return fromHex(signature);\n        if (signature instanceof Uint8Array) return fromBytes(signature);\n        if (typeof signature.r === \"string\") return fromRpc(signature);\n        if (signature.v) return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...typeof signature.yParity !== \"undefined\" ? {\n                yParity: signature.yParity\n            } : {}\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return {\n        r,\n        s\n    };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */ function fromRpc(signature) {\n    const yParity = (()=>{\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === \"number\" && typeof yParity !== \"number\") yParity = vToYParity(v);\n        if (typeof yParity !== \"number\") throw new InvalidYParityError({\n            value: signature.yParity\n        });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */ function fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === \"0x\" ? 0n : BigInt(r),\n        s: s === \"0x\" ? 0n : BigInt(s),\n        yParity: yParity === \"0x\" ? 0 : Number(yParity)\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */ function toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n        size: 32\n    }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n        size: 32\n    }), // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === \"number\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), {\n        size: 1\n    }) : \"0x\");\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */ function toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return \"0x\".concat(sig.toDERHex());\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */ function toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity)\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */ function toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, {\n            size: 32\n        }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, {\n            size: 32\n        }),\n        yParity: yParity === 0 ? \"0x0\" : \"0x1\"\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */ function toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? \"0x01\" : \"0x\",\n        r === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s))\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */ function validate(signature) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        assert(signature, options);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */ function vToYParity(v) {\n    if (v === 0 || v === 27) return 0;\n    if (v === 1 || v === 28) return 1;\n    if (v >= 35) return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({\n        value: v\n    });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */ function yParityToV(yParity) {\n    if (yParity === 0) return 27;\n    if (yParity === 1) return 28;\n    throw new InvalidYParityError({\n        value: yParity\n    });\n}\n/** Thrown when the serialized signature is of an invalid size. */ class InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(\"Value `\".concat(signature, \"` is an invalid signature size.\"), {\n            metaMessages: [\n                \"Expected: 64 bytes or 65 bytes.\",\n                \"Received \".concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature)), \" bytes.\")\n            ]\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSerializedSizeError\"\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */ class MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }){\n        super(\"Signature `\".concat(_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature), \"` is missing either an `r`, `s`, or `yParity` property.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.MissingPropertiesError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */ class InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid r value. r must be a positive integer less than 2^256.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidRError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */ class InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid s value. s must be a positive integer less than 2^256.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidSError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */ class InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid y-parity value. Y-parity must be 0 or 1.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidYParityError\"\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */ class InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is an invalid v value. v must be 27, 28 or >=35.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Signature.InvalidVError\"\n        });\n    }\n} //# sourceMappingURL=Signature.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ2hCO0FBQ0U7QUFDTjtBQUNFO0FBQ1E7QUFDMUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNNLFNBQVNNLE9BQU9DLFNBQVM7UUFBRUMsVUFBQUEsaUVBQVUsQ0FBQztJQUN6QyxNQUFNLEVBQUVDLFNBQVMsRUFBRSxHQUFHRDtJQUN0QixJQUFJLE9BQU9ELFVBQVVHLENBQUMsS0FBSyxhQUN2QixNQUFNLElBQUlDLHVCQUF1QjtRQUFFSjtJQUFVO0lBQ2pELElBQUksT0FBT0EsVUFBVUssQ0FBQyxLQUFLLGFBQ3ZCLE1BQU0sSUFBSUQsdUJBQXVCO1FBQUVKO0lBQVU7SUFDakQsSUFBSUUsYUFBYSxPQUFPRixVQUFVTSxPQUFPLEtBQUssYUFDMUMsTUFBTSxJQUFJRix1QkFBdUI7UUFBRUo7SUFBVTtJQUNqRCxJQUFJQSxVQUFVRyxDQUFDLEdBQUcsRUFBRSxJQUFJSCxVQUFVRyxDQUFDLEdBQUdMLG9EQUFtQixFQUNyRCxNQUFNLElBQUlVLGNBQWM7UUFBRUMsT0FBT1QsVUFBVUcsQ0FBQztJQUFDO0lBQ2pELElBQUlILFVBQVVLLENBQUMsR0FBRyxFQUFFLElBQUlMLFVBQVVLLENBQUMsR0FBR1Asb0RBQW1CLEVBQ3JELE1BQU0sSUFBSVksY0FBYztRQUFFRCxPQUFPVCxVQUFVSyxDQUFDO0lBQUM7SUFDakQsSUFBSSxPQUFPTCxVQUFVTSxPQUFPLEtBQUssWUFDN0JOLFVBQVVNLE9BQU8sS0FBSyxLQUN0Qk4sVUFBVU0sT0FBTyxLQUFLLEdBQ3RCLE1BQU0sSUFBSUssb0JBQW9CO1FBQUVGLE9BQU9ULFVBQVVNLE9BQU87SUFBQztBQUNqRTtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU00sVUFBVVosU0FBUztJQUMvQixPQUFPYSxR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Q0FBRTtRQUNuQixLQUFLLENBQUMsVUFBaUIsT0FBTkEsT0FBTTtRQUN2QjhDLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVmxELE9BQU87UUFDWDtJQUNKO0FBQ0osRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9TaWduYXR1cmUuanM/ZWRlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG4vKipcbiAqIEFzc2VydHMgdGhhdCBhIFNpZ25hdHVyZSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5hc3NlcnQoe1xuICogICByOiAtNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGVycm9yOiBJbnZhbGlkU2lnbmF0dXJlUkVycm9yOlxuICogLy8gQGVycm9yOiBWYWx1ZSBgLTU0OS4uLm5gIGlzIGFuIGludmFsaWQgciB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsZXNzIHRoYW4gMl4yNTYuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHNpZ25hdHVyZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyByZWNvdmVyZWQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTWlzc2luZ1Byb3BlcnRpZXNFcnJvcih7IHNpZ25hdHVyZSB9KTtcbiAgICBpZiAocmVjb3ZlcmVkICYmIHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmIChzaWduYXR1cmUuciA8IDBuIHx8IHNpZ25hdHVyZS5yID4gU29saWRpdHkubWF4VWludDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSRXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnIgfSk7XG4gICAgaWYgKHNpZ25hdHVyZS5zIDwgMG4gfHwgc2lnbmF0dXJlLnMgPiBTb2xpZGl0eS5tYXhVaW50MjU2KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUucyB9KTtcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMCAmJlxuICAgICAgICBzaWduYXR1cmUueVBhcml0eSAhPT0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gc2lnbmF0dXJlIGludG8gYSBzdHJ1Y3R1cmVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb21CeXRlcyhuZXcgVWludDhBcnJheShbMTI4LCAzLCAxMzEsIC4uLl0pKVxuICogLy8gQGxvZzogeyByOiA1MjMxLi4ubiwgczogMzUyMi4uLm4sIHlQYXJpdHk6IDAgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tSGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNIZXguSGV4fSBzaWduYXR1cmUgaW50byBhIHN0cnVjdHVyZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb21IZXgoJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgxYycpXG4gKiAvLyBAbG9nOiB7IHI6IDUyMzEuLi5uLCBzOiAzNTIyLi4ubiwgeVBhcml0eTogMCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChzaWduYXR1cmUpIHtcbiAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMwICYmIHNpZ25hdHVyZS5sZW5ndGggIT09IDEzMilcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGNvbnN0IHIgPSBCaWdJbnQoSGV4LnNsaWNlKHNpZ25hdHVyZSwgMCwgMzIpKTtcbiAgICBjb25zdCBzID0gQmlnSW50KEhleC5zbGljZShzaWduYXR1cmUsIDMyLCA2NCkpO1xuICAgIGNvbnN0IHlQYXJpdHkgPSAoKCkgPT4ge1xuICAgICAgICBjb25zdCB5UGFyaXR5ID0gTnVtYmVyKGAweCR7c2lnbmF0dXJlLnNsaWNlKDEzMCl9YCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oeVBhcml0eSkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHZUb1lQYXJpdHkoeVBhcml0eSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogeVBhcml0eSB9KTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgaWYgKHR5cGVvZiB5UGFyaXR5ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICBzLFxuICAgICAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHMsXG4gICAgICAgIHlQYXJpdHksXG4gICAgfTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gZnJvbSBhbiBhcmJpdHJhcnkgb2JqZWN0IHRoYXQgbWF5IGluY2x1ZGUgc2lnbmF0dXJlIHByb3BlcnRpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5leHRyYWN0KHtcbiAqICAgYmF6OiAnYmFycnknLFxuICogICBmb286ICdiYXInLFxuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqICAgemVicmE6ICdzdHJpcGVzJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYXJiaXRyYXJ5IG9iamVjdCB0byBleHRyYWN0IHRoZSBzaWduYXR1cmUgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBleHRyYWN0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUuciA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5zID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZnJvbSh2YWx1ZSk7XG59XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHR5cGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBvYmplY3QgZnJvbSBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSwge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKCcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MDEnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMSxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBMZWdhY3lcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oe1xuICogICByOiA0NzMyMzQ1NzAwNzQ1MzY1NzIwNzg4OTczMDI0MzgyNjk2NTc2MTkyMjI5NjU5OTY4MDQ3Mzg4NjU4ODI4NzAxNTc1NTY1MjcwMTA3Mm4sXG4gKiAgIHM6IDU3MjI4ODAzMjAyNzI3MTMxNTAyOTQ5MzU4MzEzNDU2MDcxMjgwNDg4MTg0MjcwMjU4MjkzNjc0MjQyMTI0MzQwMTEzODI0ODgyNzg4bixcbiAqICAgdjogMjcsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0NzMyMzQ1NzAwNzQ1MzY1NzIwNzg4OTczMDI0MzgyNjk2NTc2MTkyMjI5NjU5OTY4MDQ3Mzg4NjU4ODI4NzAxNTc1NTY1MjcwMTA3Mm4sXG4gKiAvLyBAbG9nOiAgIHM6IDU3MjI4ODAzMjAyNzI3MTMxNTAyOTQ5MzU4MzEzNDU2MDcxMjgwNDg4MTg0MjcwMjU4MjkzNjc0MjQyMTI0MzQwMTEzODI0ODgyNzg4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdmFsdWUgdG8gaW5zdGFudGlhdGUuXG4gKiBAcmV0dXJucyBUaGUgaW5zdGFudGlhdGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhzaWduYXR1cmUpO1xuICAgICAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5yID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBmcm9tUnBjKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmIChzaWduYXR1cmUudilcbiAgICAgICAgICAgIHJldHVybiBmcm9tTGVnYWN5KHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgLi4uKHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHsgeVBhcml0eTogc2lnbmF0dXJlLnlQYXJpdHkgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZV8pO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21EZXJCeXRlcyhuZXcgVWludDhBcnJheShbMTMyLCA1MSwgMjMsIC4uLl0pKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURlckJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBmcm9tRGVySGV4KEhleC5mcm9tQnl0ZXMoc2lnbmF0dXJlKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21EZXJIZXgoJzB4MzA0NDAyMjA2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmMDIyMDRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbURlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMgfSA9IHNlY3AyNTZrMS5TaWduYXR1cmUuZnJvbURFUihIZXguZnJvbShzaWduYXR1cmUpLnNsaWNlKDIpKTtcbiAgICByZXR1cm4geyByLCBzIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBsZWdhY3kgPSBTaWduYXR1cmUuZnJvbUxlZ2FjeSh7IHI6IDFuLCBzOiAybiwgdjogMjggfSlcbiAqIC8vIEBsb2c6IHsgcjogMW4sIHM6IDJuLCB5UGFyaXR5OiAxIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5MZWdhY3l9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21MZWdhY3koc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogc2lnbmF0dXJlLnIsXG4gICAgICAgIHM6IHNpZ25hdHVyZS5zLFxuICAgICAgICB5UGFyaXR5OiB2VG9ZUGFyaXR5KHNpZ25hdHVyZS52KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuUnBjfSBpbnRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21ScGMoe1xuICogICByOiAnMHg2MzVkYzIwMzNlNjAxODViYjM2NzA5YzI5Yzc1ZDY0ZWE1MWRmYmQ5MWMzMmVmNGJlMTk4ZTRjZWIxNjlmYjRkJyxcbiAqICAgczogJzB4NTBjMjY2N2FjNGM3NzEwNzI3NDZhY2ZkY2YxZjE0ODMzMzZkY2NhOGJkMmRmNDdjZDgzMTc1ZGJlNjBmMDU0MCcsXG4gKiAgIHlQYXJpdHk6ICcweDAnLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeVBhcml0eSA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUudiA/IE51bWJlcihzaWduYXR1cmUudikgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB5UGFyaXR5ID0gc2lnbmF0dXJlLnlQYXJpdHkgPyBOdW1iZXIoc2lnbmF0dXJlLnlQYXJpdHkpIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInICYmIHR5cGVvZiB5UGFyaXR5ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHlQYXJpdHkgPSB2VG9ZUGFyaXR5KHYpO1xuICAgICAgICBpZiAodHlwZW9mIHlQYXJpdHkgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRZUGFyaXR5RXJyb3IoeyB2YWx1ZTogc2lnbmF0dXJlLnlQYXJpdHkgfSk7XG4gICAgICAgIHJldHVybiB5UGFyaXR5O1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogQmlnSW50KHNpZ25hdHVyZS5yKSxcbiAgICAgICAgczogQmlnSW50KHNpZ25hdHVyZS5zKSxcbiAgICAgICAgeVBhcml0eSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmZyb21UdXBsZShbJzB4MDEnLCAnMHg3YicsICcweDFjOCddKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiAxMjNuLFxuICogLy8gQGxvZzogICBzOiA0NTZuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR1cGxlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlKHR1cGxlKSB7XG4gICAgY29uc3QgW3lQYXJpdHksIHIsIHNdID0gdHVwbGU7XG4gICAgcmV0dXJuIGZyb20oe1xuICAgICAgICByOiByID09PSAnMHgnID8gMG4gOiBCaWdJbnQociksXG4gICAgICAgIHM6IHMgPT09ICcweCcgPyAwbiA6IEJpZ0ludChzKSxcbiAgICAgICAgeVBhcml0eTogeVBhcml0eSA9PT0gJzB4JyA/IDAgOiBOdW1iZXIoeVBhcml0eSksXG4gICAgfSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS50b0J5dGVzKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDFcbiAqIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMDIsIDE2LCAxMCwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh0b0hleChzaWduYXR1cmUpKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9IZXgoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIC8vIEBsb2c6ICcweDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmY0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4MWMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChzaWduYXR1cmUpIHtcbiAgICBhc3NlcnQoc2lnbmF0dXJlKTtcbiAgICBjb25zdCByID0gc2lnbmF0dXJlLnI7XG4gICAgY29uc3QgcyA9IHNpZ25hdHVyZS5zO1xuICAgIGNvbnN0IHNpZ25hdHVyZV8gPSBIZXguY29uY2F0KEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksIEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksIFxuICAgIC8vIElmIHRoZSBzaWduYXR1cmUgaXMgcmVjb3ZlcmVkLCBhZGQgdGhlIHJlY292ZXJ5IGJ5dGUgdG8gdGhlIHNpZ25hdHVyZS5cbiAgICB0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICdudW1iZXInXG4gICAgICAgID8gSGV4LmZyb21OdW1iZXIoeVBhcml0eVRvVihzaWduYXR1cmUueVBhcml0eSksIHsgc2l6ZTogMSB9KVxuICAgICAgICA6ICcweCcpO1xuICAgIHJldHVybiBzaWduYXR1cmVfO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBERVItZW5jb2RlZCBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVfZGVyID0gU2lnbmF0dXJlLnRvRGVyQnl0ZXMoc2lnbmF0dXJlKVxuICogLy8gQGxvZzogVWludDhBcnJheSBbMTMyLCA1MSwgMjMsIC4uLl1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgREVSLWVuY29kZWQgc2lnbmF0dXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EZXJCeXRlcyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBzaWcudG9ERVJSYXdCeXRlcygpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBERVItZW5jb2RlZCBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVfZGVyID0gU2lnbmF0dXJlLnRvRGVySGV4KHNpZ25hdHVyZSlcbiAqIC8vIEBsb2c6ICcweDMwNDQwMjIwNmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjAyMjA0YTkwYTIyOWEyNDQ0OTViNDE4OTA5ODc4MDZmY2JkMmQ1ZDIzZmMwZGJlNWY1MjU2YzI2MTNjMDM5ZDc2ZGI4J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlckhleChzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBuZXcgc2VjcDI1NmsxLlNpZ25hdHVyZShzaWduYXR1cmUuciwgc2lnbmF0dXJlLnMpO1xuICAgIHJldHVybiBgMHgke3NpZy50b0RFUkhleCgpfWA7XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBsZWdhY3kgPSBTaWduYXR1cmUudG9MZWdhY3koeyByOiAxbiwgczogMm4sIHlQYXJpdHk6IDEgfSlcbiAqIC8vIEBsb2c6IHsgcjogMW4sIHM6IDJuLCB2OiAyOCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xlZ2FjeShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgIHY6IHlQYXJpdHlUb1Yoc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUudG9ScGMoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuUnBjfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcywgeVBhcml0eSB9ID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IEhleC5mcm9tTnVtYmVyKHIsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgIHM6IEhleC5mcm9tTnVtYmVyKHMsIHsgc2l6ZTogMzIgfSksXG4gICAgICAgIHlQYXJpdHk6IHlQYXJpdHkgPT09IDAgPyAnMHgwJyA6ICcweDEnLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGEgc2VyaWFsaXplZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfSB0byBiZSB1c2VkIGZvciBzaWduYXR1cmVzIGluIFRyYW5zYWN0aW9uIEVudmVsb3BlcywgRUlQLTc3MDIgQXV0aG9yaXphdGlvbiBMaXN0cywgZXRjLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlVHVwbGUgPSBTaWduYXR1cmUudG9UdXBsZSh7XG4gKiAgIHI6IDEyM24sXG4gKiAgIHM6IDQ1Nm4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGxvZzogW3lQYXJpdHk6ICcweDAxJywgcjogJzB4N2InLCBzOiAnMHgxYzgnXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlR1cGxlfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGUoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeVBhcml0eSA/ICcweDAxJyA6ICcweCcsXG4gICAgICAgIHIgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihyKSksXG4gICAgICAgIHMgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzKSksXG4gICAgXTtcbn1cbi8qKlxuICogVmFsaWRhdGVzIGEgU2lnbmF0dXJlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2lnbmF0dXJlIGlzIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gU2lnbmF0dXJlLnZhbGlkYXRlKHtcbiAqICAgcjogLTQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoc2lnbmF0dXJlLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoc2lnbmF0dXJlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgYSBFQ0RTQSBgdmAgdmFsdWUgdG8gYSBgeVBhcml0eWAgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB5UGFyaXR5ID0gU2lnbmF0dXJlLnZUb1lQYXJpdHkoMjgpXG4gKiAvLyBAbG9nOiAxXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSBFQ0RTQSBgdmAgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgeVBhcml0eWAgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2VG9ZUGFyaXR5KHYpIHtcbiAgICBpZiAodiA9PT0gMCB8fCB2ID09PSAyNylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKHYgPT09IDEgfHwgdiA9PT0gMjgpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmICh2ID49IDM1KVxuICAgICAgICByZXR1cm4gdiAlIDIgPT09IDAgPyAxIDogMDtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFZFcnJvcih7IHZhbHVlOiB2IH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEVDRFNBIGB2YCB2YWx1ZSB0byBhIGB5UGFyaXR5YCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHYgPSBTaWduYXR1cmUueVBhcml0eVRvVigxKVxuICogLy8gQGxvZzogMjhcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB5UGFyaXR5IC0gVGhlIEVDRFNBIGB5UGFyaXR5YCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGB2YCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlQYXJpdHlUb1YoeVBhcml0eSkge1xuICAgIGlmICh5UGFyaXR5ID09PSAwKVxuICAgICAgICByZXR1cm4gMjc7XG4gICAgaWYgKHlQYXJpdHkgPT09IDEpXG4gICAgICAgIHJldHVybiAyODtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiB5UGFyaXR5IH0pO1xufVxuLyoqIFRocm93biB3aGVuIHRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZSBpcyBvZiBhbiBpbnZhbGlkIHNpemUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3NpZ25hdHVyZX1cXGAgaXMgYW4gaW52YWxpZCBzaWduYXR1cmUgc2l6ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnRXhwZWN0ZWQ6IDY0IGJ5dGVzIG9yIDY1IGJ5dGVzLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20oc2lnbmF0dXJlKSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaXMgbWlzc2luZyBlaXRoZXIgYW4gYHJgLCBgc2AsIG9yIGB5UGFyaXR5YCBwcm9wZXJ0eS4gKi9cbmV4cG9ydCBjbGFzcyBNaXNzaW5nUHJvcGVydGllc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaWduYXR1cmUgfSkge1xuICAgICAgICBzdXBlcihgU2lnbmF0dXJlIFxcYCR7SnNvbi5zdHJpbmdpZnkoc2lnbmF0dXJlKX1cXGAgaXMgbWlzc2luZyBlaXRoZXIgYW4gXFxgclxcYCwgXFxgc1xcYCwgb3IgXFxgeVBhcml0eVxcYCBwcm9wZXJ0eS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5NaXNzaW5nUHJvcGVydGllc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgcmAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFJFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCByIHZhbHVlLiByIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkUkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgc2AgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBzIHZhbHVlLiBzIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkU0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgeVBhcml0eWAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFlQYXJpdHlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCB5LXBhcml0eSB2YWx1ZS4gWS1wYXJpdHkgbXVzdCBiZSAwIG9yIDEuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFlQYXJpdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIFRocm93biB3aGVuIHRoZSBzaWduYXR1cmUgaGFzIGFuIGludmFsaWQgYHZgIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRWRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIGFuIGludmFsaWQgdiB2YWx1ZS4gdiBtdXN0IGJlIDI3LCAyOCBvciA+PTM1LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRWRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpZ25hdHVyZS5qcy5tYXAiXSwibmFtZXMiOlsic2VjcDI1NmsxIiwiQnl0ZXMiLCJFcnJvcnMiLCJIZXgiLCJKc29uIiwiU29saWRpdHkiLCJhc3NlcnQiLCJzaWduYXR1cmUiLCJvcHRpb25zIiwicmVjb3ZlcmVkIiwiciIsIk1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IiLCJzIiwieVBhcml0eSIsIm1heFVpbnQyNTYiLCJJbnZhbGlkUkVycm9yIiwidmFsdWUiLCJJbnZhbGlkU0Vycm9yIiwiSW52YWxpZFlQYXJpdHlFcnJvciIsImZyb21CeXRlcyIsImZyb21IZXgiLCJsZW5ndGgiLCJJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvciIsIkJpZ0ludCIsInNsaWNlIiwiTnVtYmVyIiwiaXNOYU4iLCJ1bmRlZmluZWQiLCJ2VG9ZUGFyaXR5IiwiZXh0cmFjdCIsImZyb20iLCJzaWduYXR1cmVfIiwiVWludDhBcnJheSIsImZyb21ScGMiLCJ2IiwiZnJvbUxlZ2FjeSIsImZyb21EZXJCeXRlcyIsImZyb21EZXJIZXgiLCJTaWduYXR1cmUiLCJmcm9tREVSIiwiZnJvbVR1cGxlIiwidHVwbGUiLCJ0b0J5dGVzIiwidG9IZXgiLCJjb25jYXQiLCJmcm9tTnVtYmVyIiwic2l6ZSIsInlQYXJpdHlUb1YiLCJ0b0RlckJ5dGVzIiwic2lnIiwidG9ERVJSYXdCeXRlcyIsInRvRGVySGV4IiwidG9ERVJIZXgiLCJ0b0xlZ2FjeSIsInRvUnBjIiwidG9UdXBsZSIsInRyaW1MZWZ0IiwidmFsaWRhdGUiLCJJbnZhbGlkVkVycm9yIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRhTWVzc2FnZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInN0cmluZ2lmeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelope.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeeCapTooHighError: function() { return /* binding */ FeeCapTooHighError; },\n/* harmony export */   GasPriceTooHighError: function() { return /* binding */ GasPriceTooHighError; },\n/* harmony export */   InvalidChainIdError: function() { return /* binding */ InvalidChainIdError; },\n/* harmony export */   InvalidSerializedError: function() { return /* binding */ InvalidSerializedError; },\n/* harmony export */   TipAboveFeeCapError: function() { return /* binding */ TipAboveFeeCapError; }\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Value.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Value.js\");\n\n\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */ class FeeCapTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ feeCap } = {}){\n        super(\"The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas`\".concat(feeCap ? \" = \".concat(_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(feeCap), \" gwei\") : \"\", \") cannot be higher than the maximum allowed value (2^256-1).\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.FeeCapTooHighError\"\n        });\n    }\n}\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */ class GasPriceTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ gasPrice } = {}){\n        super(\"The gas price (`gasPrice`\".concat(gasPrice ? \" = \".concat(_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(gasPrice), \" gwei\") : \"\", \") cannot be higher than the maximum allowed value (2^256-1).\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.GasPriceTooHighError\"\n        });\n    }\n}\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */ class InvalidChainIdError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ chainId }){\n        super(typeof chainId !== \"undefined\" ? 'Chain ID \"'.concat(chainId, '\" is invalid.') : \"Chain ID is invalid.\");\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.InvalidChainIdError\"\n        });\n    }\n}\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */ class InvalidSerializedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ attributes, serialized, type }){\n        const missing = Object.entries(attributes).map((param)=>{\n            let [key, value] = param;\n            return typeof value === \"undefined\" ? key : undefined;\n        }).filter(Boolean);\n        super('Invalid serialized transaction of type \"'.concat(type, '\" was provided.'), {\n            metaMessages: [\n                'Serialized Transaction: \"'.concat(serialized, '\"'),\n                missing.length > 0 ? \"Missing Attributes: \".concat(missing.join(\", \")) : \"\"\n            ].filter(Boolean)\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.InvalidSerializedError\"\n        });\n    }\n}\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */ class TipAboveFeeCapError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}){\n        super([\n            \"The provided tip (`maxPriorityFeePerGas`\".concat(maxPriorityFeePerGas ? \" = \".concat(_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxPriorityFeePerGas), \" gwei\") : \"\", \") cannot be higher than the fee cap (`maxFeePerGas`\").concat(maxFeePerGas ? \" = \".concat(_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxFeePerGas), \" gwei\") : \"\", \").\")\n        ].join(\"\\n\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"TransactionEnvelope.TipAboveFeeCapError\"\n        });\n    }\n} //# sourceMappingURL=TransactionEnvelope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNDO0FBQ0Y7QUFDcEM7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU1FLDJCQUEyQkYsaURBQWdCO0lBQ3BESSxZQUFZLEVBQUVDLE1BQU0sRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzFCLEtBQUssQ0FBQyxxREFBNkcsT0FBcERBLFNBQVMsTUFBK0IsT0FBekJKLGlEQUFnQixDQUFDSSxTQUFRLFdBQVMsSUFBRztRQUNuSEUsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNNLE1BQU1DLDZCQUE2QmIsaURBQWdCO0lBQ3RESSxZQUFZLEVBQUVVLFFBQVEsRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzVCLEtBQUssQ0FBQyw0QkFBc0YsT0FBeERBLFdBQVcsTUFBaUMsT0FBM0JiLGlEQUFnQixDQUFDYSxXQUFVLFdBQVMsSUFBRztRQUM1RlAsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU1HLDRCQUE0QmYsaURBQWdCO0lBQ3JESSxZQUFZLEVBQUVZLE9BQU8sRUFBRSxDQUFFO1FBQ3JCLEtBQUssQ0FBQyxPQUFPQSxZQUFZLGNBQ25CLGFBQXFCLE9BQVJBLFNBQVEsbUJBQ3JCO1FBQ05ULE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNoQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUNNLE1BQU1LLCtCQUErQmpCLGlEQUFnQjtJQUN4REksWUFBWSxFQUFFYyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDM0MsTUFBTUMsVUFBVWQsT0FBT2UsT0FBTyxDQUFDSixZQUMxQkssR0FBRyxDQUFDO2dCQUFDLENBQUNDLEtBQUtaLE1BQU07bUJBQU0sT0FBT0EsVUFBVSxjQUFjWSxNQUFNQztXQUM1REMsTUFBTSxDQUFDQztRQUNaLEtBQUssQ0FBQywyQ0FBZ0QsT0FBTFAsTUFBSyxvQkFBa0I7WUFDcEVRLGNBQWM7Z0JBQ1QsNEJBQXNDLE9BQVhULFlBQVc7Z0JBQ3ZDRSxRQUFRUSxNQUFNLEdBQUcsSUFBSSx1QkFBMEMsT0FBbkJSLFFBQVFTLElBQUksQ0FBQyxTQUFVO2FBQ3RFLENBQUNKLE1BQU0sQ0FBQ0M7UUFDYjtRQUNBcEIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxNQUFNbUIsNEJBQTRCL0IsaURBQWdCO0lBQ3JESSxZQUFZLEVBQUU0QixvQkFBb0IsRUFBRUMsWUFBWSxFQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUU7UUFDdEQsS0FBSyxDQUFDO1lBQ0QsMkNBRStEQSxPQUZuQkQsdUJBQ3ZDLE1BQTZDLE9BQXZDL0IsaURBQWdCLENBQUMrQix1QkFBc0IsV0FDN0MsSUFBRyx1REFBdUgsT0FBaEVDLGVBQWUsTUFBcUMsT0FBL0JoQyxpREFBZ0IsQ0FBQ2dDLGVBQWMsV0FBUyxJQUFHO1NBQ25JLENBQUNILElBQUksQ0FBQztRQUNQdkIsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPO1FBQ1g7SUFDSjtBQUNKLEVBQ0EsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZS5qcz8yMjM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBWYWx1ZSBmcm9tICcuL1ZhbHVlLmpzJztcbi8qKlxuICogVGhyb3duIHdoZW4gYSBmZWUgY2FwIGlzIHRvbyBoaWdoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBtYXhGZWVQZXJHYXM6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3I6IFRoZSBmZWUgY2FwIChgbWF4RmVlUGVyR2FzYC9gbWF4UHJpb3JpdHlGZWVQZXJHYXNgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzLjEyOTYzOTkzNiBnd2VpKSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEZlZUNhcFRvb0hpZ2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZmVlQ2FwLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoYFRoZSBmZWUgY2FwIChcXGBtYXhGZWVQZXJHYXNcXGAvXFxgbWF4UHJpb3JpdHlGZWVQZXJHYXNcXGAke2ZlZUNhcCA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkoZmVlQ2FwKX0gZ3dlaWAgOiAnJ30pIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuRmVlQ2FwVG9vSGlnaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgZ2FzIHByaWNlIGlzIHRvbyBoaWdoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5HYXNQcmljZVRvb0hpZ2hFcnJvcjogVGhlIGdhcyBwcmljZSAoYGdhc1ByaWNlYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMy4xMjk2Mzk5MzYgZ3dlaSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBHYXNQcmljZVRvb0hpZ2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZ2FzUHJpY2UsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihgVGhlIGdhcyBwcmljZSAoXFxgZ2FzUHJpY2VcXGAke2dhc1ByaWNlID8gYCA9ICR7VmFsdWUuZm9ybWF0R3dlaShnYXNQcmljZSl9IGd3ZWlgIDogJyd9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkdhc1ByaWNlVG9vSGlnaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgY2hhaW4gSUQgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHsgY2hhaW5JZDogMCB9KVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3I6IENoYWluIElEIFwiMFwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDaGFpbklkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNoYWluSWQgfSkge1xuICAgICAgICBzdXBlcih0eXBlb2YgY2hhaW5JZCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gYENoYWluIElEIFwiJHtjaGFpbklkfVwiIGlzIGludmFsaWQuYFxuICAgICAgICAgICAgOiAnQ2hhaW4gSUQgaXMgaW52YWxpZC4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZGVzZXJpYWxpemUoJzB4MDJjMCcpXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcjogSW52YWxpZCBzZXJpYWxpemVkIHRyYW5zYWN0aW9uIG9mIHR5cGUgXCJlaXAxNTU5XCIgd2FzIHByb3ZpZGVkLlxuICogLy8gQGVycm9yOiBTZXJpYWxpemVkIFRyYW5zYWN0aW9uOiBcIjB4MDJjMFwiXG4gKiAvLyBAZXJyb3I6IE1pc3NpbmcgQXR0cmlidXRlczogY2hhaW5JZCwgbm9uY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBhY2Nlc3NMaXN0XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTZXJpYWxpemVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGF0dHJpYnV0ZXMsIHNlcmlhbGl6ZWQsIHR5cGUsIH0pIHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+ICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8ga2V5IDogdW5kZWZpbmVkKSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb2YgdHlwZSBcIiR7dHlwZX1cIiB3YXMgcHJvdmlkZWQuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgYFNlcmlhbGl6ZWQgVHJhbnNhY3Rpb246IFwiJHtzZXJpYWxpemVkfVwiYCxcbiAgICAgICAgICAgICAgICBtaXNzaW5nLmxlbmd0aCA+IDAgPyBgTWlzc2luZyBBdHRyaWJ1dGVzOiAke21pc3Npbmcuam9pbignLCAnKX1gIDogJycsXG4gICAgICAgICAgICBdLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB0aXAgaXMgaGlnaGVyIHRoYW4gYSBmZWUgY2FwLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IDEwbixcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IDExbixcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuVGlwQWJvdmVGZWVDYXBFcnJvcjogVGhlIHByb3ZpZGVkIHRpcCAoYG1heFByaW9yaXR5RmVlUGVyR2FzYCA9IDExIGd3ZWkpIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgZmVlIGNhcCAoYG1heEZlZVBlckdhc2AgPSAxMCBnd2VpKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgVGlwQWJvdmVGZWVDYXBFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKFtcbiAgICAgICAgICAgIGBUaGUgcHJvdmlkZWQgdGlwIChcXGBtYXhQcmlvcml0eUZlZVBlckdhc1xcYCR7bWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA/IGAgPSAke1ZhbHVlLmZvcm1hdEd3ZWkobWF4UHJpb3JpdHlGZWVQZXJHYXMpfSBnd2VpYFxuICAgICAgICAgICAgICAgIDogJyd9KSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIGZlZSBjYXAgKFxcYG1heEZlZVBlckdhc1xcYCR7bWF4RmVlUGVyR2FzID8gYCA9ICR7VmFsdWUuZm9ybWF0R3dlaShtYXhGZWVQZXJHYXMpfSBnd2VpYCA6ICcnfSkuYCxcbiAgICAgICAgXS5qb2luKCdcXG4nKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2FjdGlvbkVudmVsb3BlLlRpcEFib3ZlRmVlQ2FwRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uRW52ZWxvcGUuanMubWFwIl0sIm5hbWVzIjpbIkVycm9ycyIsIlZhbHVlIiwiRmVlQ2FwVG9vSGlnaEVycm9yIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJmZWVDYXAiLCJmb3JtYXRHd2VpIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsIkdhc1ByaWNlVG9vSGlnaEVycm9yIiwiZ2FzUHJpY2UiLCJJbnZhbGlkQ2hhaW5JZEVycm9yIiwiY2hhaW5JZCIsIkludmFsaWRTZXJpYWxpemVkRXJyb3IiLCJhdHRyaWJ1dGVzIiwic2VyaWFsaXplZCIsInR5cGUiLCJtaXNzaW5nIiwiZW50cmllcyIsIm1hcCIsImtleSIsInVuZGVmaW5lZCIsImZpbHRlciIsIkJvb2xlYW4iLCJtZXRhTWVzc2FnZXMiLCJsZW5ndGgiLCJqb2luIiwiVGlwQWJvdmVGZWVDYXBFcnJvciIsIm1heFByaW9yaXR5RmVlUGVyR2FzIiwibWF4RmVlUGVyR2FzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   deserialize: function() { return /* binding */ deserialize; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   serializedType: function() { return /* binding */ serializedType; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\n\nconst serializedType = \"0x02\";\nconst type = \"eip1559\";\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = envelope;\n    if (chainId <= 0) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidChainIdError({\n        chainId\n    });\n    if (to) _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(to, {\n        strict: false\n    });\n    if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.FeeCapTooHighError({\n        feeCap: maxFeePerGas\n    });\n    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.TipAboveFeeCapError({\n        maxFeePerGas,\n        maxPriorityFeePerGas\n    });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.deserialize('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip1559',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, yParity, r, s] = transactionArray;\n    if (!(transactionArray.length === 9 || transactionArray.length === 12)) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidSerializedError({\n        attributes: {\n            chainId,\n            nonce,\n            maxPriorityFeePerGas,\n            maxFeePerGas,\n            gas,\n            to,\n            value,\n            data,\n            accessList,\n            ...transactionArray.length > 9 ? {\n                yParity,\n                r,\n                s\n            } : {}\n        },\n        serialized,\n        type\n    });\n    let transaction = {\n        chainId: Number(chainId),\n        type\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== \"0x\") transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== \"0x\") transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== \"0x\") transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== \"0x\") transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxFeePerGas) && maxFeePerGas !== \"0x\") transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== \"0x\") transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== \"0x\") transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.fromTuple([\n        yParity,\n        r,\n        s\n    ]) : undefined;\n    if (signature) transaction = {\n        ...transaction,\n        ...signature\n    };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-1559 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-1559 Transaction Envelope from a {@link ox#TransactionEnvelopeEip1559.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from('0x02f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-1559 Transaction Envelope.\n */ function from(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.from(signature) : {},\n        type: \"eip1559\"\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip1559.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-1559 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_6__.keccak256(serialize({\n        ...envelope,\n        ...presign ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined\n        } : {}\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(options.signature || envelope);\n    var _ref;\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : \"0x\",\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxPriorityFeePerGas) : \"0x\",\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxFeePerGas) : \"0x\",\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : \"0x\",\n        to !== null && to !== void 0 ? to : \"0x\",\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : \"0x\",\n        (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : \"0x\",\n        accessTupleList,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toTuple(signature) : []\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(serializedType, _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} to an {@link ox#TransactionEnvelopeEip1559.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip1559.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-1559 transaction envelope to convert.\n * @returns An RPC-formatted EIP-1559 transaction envelope.\n */ function toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(envelope);\n    var _envelope_data;\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId),\n        data: (_envelope_data = envelope.data) !== null && _envelope_data !== void 0 ? _envelope_data : envelope.input,\n        type: \"0x2\",\n        ...typeof envelope.gas === \"bigint\" ? {\n            gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas)\n        } : {},\n        ...typeof envelope.nonce === \"bigint\" ? {\n            nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce)\n        } : {},\n        ...typeof envelope.value === \"bigint\" ? {\n            value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value)\n        } : {},\n        ...typeof envelope.maxFeePerGas === \"bigint\" ? {\n            maxFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.maxFeePerGas)\n        } : {},\n        ...typeof envelope.maxPriorityFeePerGas === \"bigint\" ? {\n            maxPriorityFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.maxPriorityFeePerGas)\n        } : {},\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toRpc(signature) : {}\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=TransactionEnvelopeEip1559.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDTjtBQUNOO0FBQ0Y7QUFDQTtBQUNZO0FBQ29CO0FBQ3pELE1BQU1PLGlCQUFpQixPQUFPO0FBQzlCLE1BQU1DLE9BQU8sVUFBVTtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNDLE9BQU9DLFFBQVE7SUFDM0IsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLG9CQUFvQixFQUFFQyxZQUFZLEVBQUVDLEVBQUUsRUFBRSxHQUFHSjtJQUM1RCxJQUFJQyxXQUFXLEdBQ1gsTUFBTSxJQUFJTCx3RUFBdUMsQ0FBQztRQUFFSztJQUFRO0lBQ2hFLElBQUlHLElBQ0FiLCtDQUFjLENBQUNhLElBQUk7UUFBRUUsUUFBUTtJQUFNO0lBQ3ZDLElBQUlILGdCQUFnQkksT0FBT0osZ0JBQWdCLEVBQUUsSUFBSSxJQUFJLEdBQUcsRUFBRSxFQUN0RCxNQUFNLElBQUlQLHVFQUFzQyxDQUFDO1FBQUVhLFFBQVFOO0lBQWE7SUFDNUUsSUFBSUQsd0JBQ0FDLGdCQUNBRCx1QkFBdUJDLGNBQ3ZCLE1BQU0sSUFBSVAsd0VBQXVDLENBQUM7UUFDOUNPO1FBQ0FEO0lBQ0o7QUFDUjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUNNLFNBQVNTLFlBQVlDLFVBQVU7SUFDbEMsTUFBTUMsbUJBQW1CbkIsMENBQVMsQ0FBQ0QsMENBQVMsQ0FBQ21CLFlBQVk7SUFDekQsTUFBTSxDQUFDWCxTQUFTZSxPQUFPZCxzQkFBc0JDLGNBQWNjLEtBQUtiLElBQUljLE9BQU9DLE1BQU1DLFlBQVlDLFNBQVNDLEdBQUdDLEVBQUcsR0FBR1Y7SUFDL0csSUFBSSxDQUFFQSxDQUFBQSxpQkFBaUJXLE1BQU0sS0FBSyxLQUFLWCxpQkFBaUJXLE1BQU0sS0FBSyxFQUFD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Q08sU0FBU2lCLEdBQUc7UUFBRSxJQUNwQyxDQUFDLENBQUM7UUFDUixHQUFJLE9BQU9qQixTQUFTZ0IsS0FBSyxLQUFLLFdBQ3hCO1lBQUVBLE9BQU92QiwrQ0FBYyxDQUFDTyxTQUFTZ0IsS0FBSztRQUFFLElBQ3hDLENBQUMsQ0FBQztRQUNSLEdBQUksT0FBT2hCLFNBQVNrQixLQUFLLEtBQUssV0FDeEI7WUFBRUEsT0FBT3pCLCtDQUFjLENBQUNPLFNBQVNrQixLQUFLO1FBQUUsSUFDeEMsQ0FBQyxDQUFDO1FBQ1IsR0FBSSxPQUFPbEIsU0FBU0csWUFBWSxLQUFLLFdBQy9CO1lBQUVBLGNBQWNWLCtDQUFjLENBQUNPLFNBQVNHLFlBQVk7UUFBRSxJQUN0RCxDQUFDLENBQUM7UUFDUixHQUFJLE9BQU9ILFNBQVNFLG9CQUFvQixLQUFLLFdBQ3ZDO1lBQ0VBLHNCQUFzQlQsK0NBQWMsQ0FBQ08sU0FBU0Usb0JBQW9CO1FBQ3RFLElBQ0UsQ0FBQyxDQUFDO1FBQ1IsR0FBSTZCLFlBQVlwQyxnREFBZSxDQUFDb0MsYUFBYSxDQUFDLENBQUM7SUFDbkQ7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNGLFNBQVM3QixRQUFRO0lBQzdCLElBQUk7UUFDQUQsT0FBT0M7UUFDUCxPQUFPO0lBQ1gsRUFDQSxVQUFNO1FBQ0YsT0FBTztJQUNYO0FBQ0osRUFDQSxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5qcz9hYzkxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFjY2Vzc0xpc3QgZnJvbSAnLi9BY2Nlc3NMaXN0LmpzJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBSbHAgZnJvbSAnLi9SbHAuanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4vU2lnbmF0dXJlLmpzJztcbmltcG9ydCAqIGFzIFRyYW5zYWN0aW9uRW52ZWxvcGUgZnJvbSAnLi9UcmFuc2FjdGlvbkVudmVsb3BlLmpzJztcbmV4cG9ydCBjb25zdCBzZXJpYWxpemVkVHlwZSA9ICcweDAyJztcbmV4cG9ydCBjb25zdCB0eXBlID0gJ2VpcDE1NTknO1xuLyoqXG4gKiBBc3NlcnRzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydCh7XG4gKiAgIG1heEZlZVBlckdhczogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBlcnJvcjogRmVlQ2FwVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZmVlIGNhcCAoYG1hc0ZlZVBlckdhc2AgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMgZ3dlaSkgY2Fubm90IGJlXG4gKiAvLyBAZXJyb3I6IGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChlbnZlbG9wZSkge1xuICAgIGNvbnN0IHsgY2hhaW5JZCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgdG8gfSA9IGVudmVsb3BlO1xuICAgIGlmIChjaGFpbklkIDw9IDApXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3IoeyBjaGFpbklkIH0pO1xuICAgIGlmICh0bylcbiAgICAgICAgQWRkcmVzcy5hc3NlcnQodG8sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBpZiAobWF4RmVlUGVyR2FzICYmIEJpZ0ludChtYXhGZWVQZXJHYXMpID4gMm4gKiogMjU2biAtIDFuKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3IoeyBmZWVDYXA6IG1heEZlZVBlckdhcyB9KTtcbiAgICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgICAgbWF4RmVlUGVyR2FzICYmXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID4gbWF4RmVlUGVyR2FzKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5UaXBBYm92ZUZlZUNhcEVycm9yKHtcbiAgICAgICAgICAgIG1heEZlZVBlckdhcyxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICB9KTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fSBmcm9tIGl0cyBzZXJpYWxpemVkIGZvcm0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZGVzZXJpYWxpemUoJzB4MDJlZjAxODIwMzExODQ3NzM1OTQwMDg0NzczNTk0MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzAnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICB0eXBlOiAnZWlwMTU1OScsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA3ODVuLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25BcnJheSA9IFJscC50b0hleChIZXguc2xpY2Uoc2VyaWFsaXplZCwgMSkpO1xuICAgIGNvbnN0IFtjaGFpbklkLCBub25jZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzLCB0bywgdmFsdWUsIGRhdGEsIGFjY2Vzc0xpc3QsIHlQYXJpdHksIHIsIHMsXSA9IHRyYW5zYWN0aW9uQXJyYXk7XG4gICAgaWYgKCEodHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDkgfHwgdHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDEyKSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYWNjZXNzTGlzdCxcbiAgICAgICAgICAgICAgICAuLi4odHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPiA5XG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeVBhcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICBsZXQgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgdHlwZSxcbiAgICB9O1xuICAgIGlmIChIZXgudmFsaWRhdGUodG8pICYmIHRvICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHRvO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzKSAmJiBnYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhcyA9IEJpZ0ludChnYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZGF0YSkgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkgJiYgbm9uY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUobWF4RmVlUGVyR2FzKSAmJiBtYXhGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyA9IEJpZ0ludChtYXhGZWVQZXJHYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUobWF4UHJpb3JpdHlGZWVQZXJHYXMpICYmIG1heFByaW9yaXR5RmVlUGVyR2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ0ludChtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKGFjY2Vzc0xpc3QubGVuZ3RoICE9PSAwICYmIGFjY2Vzc0xpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gciAmJiBzICYmIHlQYXJpdHkgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNpZ25hdHVyZSlcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGFuIEVJUC0xNTU5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAxNTU5JyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtMTU1OSBUcmFuc2FjdGlvbiBFbnZlbG9wZSBmcm9tIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbSgnMHgwMmY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDE1NTknLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBBbiBFSVAtMTU1OSBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVudmVsb3BlXyA9ICh0eXBlb2YgZW52ZWxvcGUgPT09ICdzdHJpbmcnID8gZGVzZXJpYWxpemUoZW52ZWxvcGUpIDogZW52ZWxvcGUpO1xuICAgIGFzc2VydChlbnZlbG9wZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlXyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSkgOiB7fSksXG4gICAgICAgIHR5cGU6ICdlaXAxNTU5JyxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXlsb2FkIHRvIHNpZ24gZm9yIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gZ2V0IHRoZSBzaWduIHBheWxvYWQgZm9yLlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSB7XG4gICAgcmV0dXJuIGhhc2goZW52ZWxvcGUsIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbi8qKlxuICogSGFzaGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fS4gVGhpcyBpcyB0aGUgXCJ0cmFuc2FjdGlvbiBoYXNoXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5Lmhhc2goZW52ZWxvcGVfc2lnbmVkKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTE1NTkgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIC4uLiBzZW5kIGBzZXJpYWxpemVkYCB0cmFuc2FjdGlvbiB0byBKU09OLVJQQyBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXMsIG5vbmNlLCB0bywgdmFsdWUsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGFjY2Vzc0xpc3QsIGRhdGEsIGlucHV0LCB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBjb25zdCBhY2Nlc3NUdXBsZUxpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KG9wdGlvbnMuc2lnbmF0dXJlIHx8IGVudmVsb3BlKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gW1xuICAgICAgICBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heFByaW9yaXR5RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIG1heEZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heEZlZVBlckdhcykgOiAnMHgnLFxuICAgICAgICBnYXMgPyBIZXguZnJvbU51bWJlcihnYXMpIDogJzB4JyxcbiAgICAgICAgdG8gPz8gJzB4JyxcbiAgICAgICAgdmFsdWUgPyBIZXguZnJvbU51bWJlcih2YWx1ZSkgOiAnMHgnLFxuICAgICAgICBkYXRhID8/IGlucHV0ID8/ICcweCcsXG4gICAgICAgIGFjY2Vzc1R1cGxlTGlzdCxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1R1cGxlKHNpZ25hdHVyZSkgOiBbXSksXG4gICAgXTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChzZXJpYWxpemVkVHlwZSwgUmxwLmZyb21IZXgoc2VyaWFsaXplZCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTE1NTkgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhlbnZlbG9wZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGVudmVsb3BlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZCksXG4gICAgICAgIGRhdGE6IGVudmVsb3BlLmRhdGEgPz8gZW52ZWxvcGUuaW5wdXQsXG4gICAgICAgIHR5cGU6ICcweDInLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLmdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBnYXM6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLmdhcykgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubm9uY2UgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgbm9uY2U6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLm5vbmNlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS52YWx1ZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyB2YWx1ZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUudmFsdWUpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLm1heEZlZVBlckdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBtYXhGZWVQZXJHYXM6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLm1heEZlZVBlckdhcykgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBtYXhGZWVQZXJHYXM6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoZW52ZWxvcGUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuanMubWFwIl0sIm5hbWVzIjpbIkFjY2Vzc0xpc3QiLCJBZGRyZXNzIiwiSGFzaCIsIkhleCIsIlJscCIsIlNpZ25hdHVyZSIsIlRyYW5zYWN0aW9uRW52ZWxvcGUiLCJzZXJpYWxpemVkVHlwZSIsInR5cGUiLCJhc3NlcnQiLCJlbnZlbG9wZSIsImNoYWluSWQiLCJtYXhQcmlvcml0eUZlZVBlckdhcyIsIm1heEZlZVBlckdhcyIsInRvIiwiSW52YWxpZENoYWluSWRFcnJvciIsInN0cmljdCIsIkJpZ0ludCIsIkZlZUNhcFRvb0hpZ2hFcnJvciIsImZlZUNhcCIsIlRpcEFib3ZlRmVlQ2FwRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0cmFuc2FjdGlvbkFycmF5IiwidG9IZXgiLCJzbGljZSIsIm5vbmNlIiwiZ2FzIiwidmFsdWUiLCJkYXRhIiwiYWNjZXNzTGlzdCIsInlQYXJpdHkiLCJyIiwicyIsImxlbmd0aCIsIkludmFsaWRTZXJpYWxpemVkRXJyb3IiLCJhdHRyaWJ1dGVzIiwidHJhbnNhY3Rpb24iLCJOdW1iZXIiLCJ2YWxpZGF0ZSIsImZyb21UdXBsZUxpc3QiLCJzaWduYXR1cmUiLCJmcm9tVHVwbGUiLCJ1bmRlZmluZWQiLCJmcm9tIiwib3B0aW9ucyIsImVudmVsb3BlXyIsImdldFNpZ25QYXlsb2FkIiwiaGFzaCIsInByZXNpZ24iLCJrZWNjYWsyNTYiLCJzZXJpYWxpemUiLCJ2IiwiaW5wdXQiLCJhY2Nlc3NUdXBsZUxpc3QiLCJ0b1R1cGxlTGlzdCIsImV4dHJhY3QiLCJmcm9tTnVtYmVyIiwidG9UdXBsZSIsImNvbmNhdCIsImZyb21IZXgiLCJ0b1JwYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   deserialize: function() { return /* binding */ deserialize; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   serializedType: function() { return /* binding */ serializedType; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\n\nconst serializedType = \"0x01\";\nconst type = \"eip2930\";\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (chainId <= 0) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidChainIdError({\n        chainId\n    });\n    if (to) _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(to, {\n        strict: false\n    });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.GasPriceTooHighError({\n        gasPrice\n    });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip2930',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, yParity, r, s] = transactionArray;\n    if (!(transactionArray.length === 8 || transactionArray.length === 11)) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidSerializedError({\n        attributes: {\n            chainId,\n            nonce,\n            gasPrice,\n            gas,\n            to,\n            value,\n            data,\n            accessList,\n            ...transactionArray.length > 8 ? {\n                yParity,\n                r,\n                s\n            } : {}\n        },\n        serialized,\n        type\n    });\n    let transaction = {\n        chainId: Number(chainId),\n        type\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== \"0x\") transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== \"0x\") transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== \"0x\") transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== \"0x\") transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gasPrice) && gasPrice !== \"0x\") transaction.gasPrice = BigInt(gasPrice);\n    if (accessList.length !== 0 && accessList !== \"0x\") transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.fromTuple([\n        yParity,\n        r,\n        s\n    ]) : undefined;\n    if (signature) transaction = {\n        ...transaction,\n        ...signature\n    };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-2930 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-2930 Transaction Envelope from a {@link ox#TransactionEnvelopeEip2930.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from('0x01f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}\n */ function from(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.from(signature) : {},\n        type: \"eip2930\"\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, {\n *   signature,\n * })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-2930 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_6__.keccak256(serialize({\n        ...envelope,\n        ...presign ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined\n        } : {}\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { chainId, gas, data, input, nonce, to, value, accessList, gasPrice } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(options.signature || envelope);\n    var _ref;\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : \"0x\",\n        gasPrice ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gasPrice) : \"0x\",\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : \"0x\",\n        to !== null && to !== void 0 ? to : \"0x\",\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : \"0x\",\n        (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : \"0x\",\n        accessTupleList,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toTuple(signature) : []\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(\"0x01\", _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} to an {@link ox#TransactionEnvelopeEip2930.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-2930 transaction envelope to convert.\n * @returns An RPC-formatted EIP-2930 transaction envelope.\n */ function toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(envelope);\n    var _envelope_data;\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId),\n        data: (_envelope_data = envelope.data) !== null && _envelope_data !== void 0 ? _envelope_data : envelope.input,\n        ...typeof envelope.gas === \"bigint\" ? {\n            gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas)\n        } : {},\n        ...typeof envelope.nonce === \"bigint\" ? {\n            nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce)\n        } : {},\n        ...typeof envelope.value === \"bigint\" ? {\n            value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value)\n        } : {},\n        ...typeof envelope.gasPrice === \"bigint\" ? {\n            gasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gasPrice)\n        } : {},\n        type: \"0x1\",\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toRpc(signature) : {}\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=TransactionEnvelopeEip2930.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDTjtBQUNOO0FBQ0Y7QUFDQTtBQUNZO0FBQ29CO0FBQ3pELE1BQU1PLGlCQUFpQixPQUFPO0FBQzlCLE1BQU1DLE9BQU8sVUFBVTtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNNLFNBQVNDLE9BQU9DLFFBQVE7SUFDM0IsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsRUFBRSxFQUFFLEdBQUdIO0lBQ2xDLElBQUlDLFdBQVcsR0FDWCxNQUFNLElBQUlMLHdFQUF1QyxDQUFDO1FBQUVLO0lBQVE7SUFDaEUsSUFBSUUsSUFDQVosK0NBQWMsQ0FBQ1ksSUFBSTtRQUFFRSxRQUFRO0lBQU07SUFDdkMsSUFBSUgsWUFBWUksT0FBT0osWUFBWSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsRUFDOUMsTUFBTSxJQUFJTix5RUFBd0MsQ0FBQztRQUFFTTtJQUFTO0FBQ3RFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ00sU0FBU00sWUFBWUMsVUFBVTtJQUNsQyxNQUFNQyxtQkFBbUJoQiwwQ0FBUyxDQUFDRCwwQ0FBUyxDQUFDZ0IsWUFBWTtJQUN6RCxNQUFNLENBQUNSLFNBQVNZLE9BQU9YLFVBQVVZLEtBQUtYLElBQUlZLE9BQU9DLE1BQU1DLFlBQVlDLFNBQVNDLEdBQUdDLEVBQUcsR0FBR1Y7SUFDckYsSUFBSSxDQUFFQSxDQUFBQSxpQkFBaUJXLE1BQU0sS0FBSyxLQUFLWCxpQkFBaUJXLE1BQU0sS0FBSyxFQUFDLEdBQ2hFLE1BQU0sSUFBSXpCLDJFQUEwQyxDQUFDO1FBQ2pEMkIsWUFBWTtZQUNSdEI7WUFDQVk7WUFDQVg7WUFDQVk7WUFDQVg7WUFDQVk7WUFDQUM7WUFDQUM7WUFDQSxHQUFJUCxpQkFBaUJX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QUFFQSxVQUFVVCwrQ0FBYyxDQUFDTyxTQUFTRSxRQUFRO1FBQUUsSUFDOUMsQ0FBQyxDQUFDO1FBQ1JKLE1BQU07UUFDTixHQUFJOEIsWUFBWWpDLGdEQUFlLENBQUNpQyxhQUFhLENBQUMsQ0FBQztJQUNuRDtBQUNKO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ00sU0FBU0YsU0FBUzFCLFFBQVE7SUFDN0IsSUFBSTtRQUNBRCxPQUFPQztRQUNQLE9BQU87SUFDWCxFQUNBLFVBQU07UUFDRixPQUFPO0lBQ1g7QUFDSixFQUNBLHNEQUFzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmpzPzYwZDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWNjZXNzTGlzdCBmcm9tICcuL0FjY2Vzc0xpc3QuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZWRUeXBlID0gJzB4MDEnO1xuZXhwb3J0IGNvbnN0IHR5cGUgPSAnZWlwMjkzMCc7XG4vKipcbiAqIEFzc2VydHMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEdhc1ByaWNlVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZ2FzIHByaWNlIChgZ2FzUHJpY2VgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzIGd3ZWkpIGNhbm5vdCBiZVxuICogLy8gQGVycm9yOiBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB7IGNoYWluSWQsIGdhc1ByaWNlLCB0byB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKGNoYWluSWQgPD0gMClcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gICAgaWYgKHRvKVxuICAgICAgICBBZGRyZXNzLmFzc2VydCh0bywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGlmIChnYXNQcmljZSAmJiBCaWdJbnQoZ2FzUHJpY2UpID4gMm4gKiogMjU2biAtIDFuKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5HYXNQcmljZVRvb0hpZ2hFcnJvcih7IGdhc1ByaWNlIH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IGZyb20gaXRzIHNlcmlhbGl6ZWQgZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5kZXNlcmlhbGl6ZSgnMHgwMWVmMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAyOTMwJyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAyMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgZ2FzOiAxMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQXJyYXkgPSBSbHAudG9IZXgoSGV4LnNsaWNlKHNlcmlhbGl6ZWQsIDEpKTtcbiAgICBjb25zdCBbY2hhaW5JZCwgbm9uY2UsIGdhc1ByaWNlLCBnYXMsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdCwgeVBhcml0eSwgciwgcyxdID0gdHJhbnNhY3Rpb25BcnJheTtcbiAgICBpZiAoISh0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gOCB8fCB0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTEpKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlLFxuICAgICAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3QsXG4gICAgICAgICAgICAgICAgLi4uKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID4gOFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlQYXJpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgfSk7XG4gICAgbGV0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIHR5cGUsXG4gICAgfTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHRvKSAmJiB0byAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udG8gPSB0bztcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGdhcykgJiYgZ2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXMgPSBCaWdJbnQoZ2FzKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGRhdGEpICYmIGRhdGEgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSBkYXRhO1xuICAgIGlmIChIZXgudmFsaWRhdGUobm9uY2UpICYmIG5vbmNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5ub25jZSA9IEJpZ0ludChub25jZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZSh2YWx1ZSkgJiYgdmFsdWUgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGdhc1ByaWNlKSAmJiBnYXNQcmljZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzUHJpY2UgPSBCaWdJbnQoZ2FzUHJpY2UpO1xuICAgIGlmIChhY2Nlc3NMaXN0Lmxlbmd0aCAhPT0gMCAmJiBhY2Nlc3NMaXN0ICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC5mcm9tVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHIgJiYgcyAmJiB5UGFyaXR5ID8gU2lnbmF0dXJlLmZyb21UdXBsZShbeVBhcml0eSwgciwgc10pIDogdW5kZWZpbmVkO1xuICAgIGlmIChzaWduYXR1cmUpXG4gICAgICAgIHRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgICAgIH07XG4gICAgYXNzZXJ0KHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiBvYmplY3QgaW50byBhbiBFSVAtMjkzMCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgYWNjZXNzTGlzdDogWy4uLl0sXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBnYXNQcmljZTogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAyOTMwJyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtMjkzMCBUcmFuc2FjdGlvbiBFbnZlbG9wZSBmcm9tIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSgnMHgwMWY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDI5MzAnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVudmVsb3BlXyA9ICh0eXBlb2YgZW52ZWxvcGUgPT09ICdzdHJpbmcnID8gZGVzZXJpYWxpemUoZW52ZWxvcGUpIDogZW52ZWxvcGUpO1xuICAgIGFzc2VydChlbnZlbG9wZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlXyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSkgOiB7fSksXG4gICAgICAgIHR5cGU6ICdlaXAyOTMwJyxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXlsb2FkIHRvIHNpZ24gZm9yIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIHtcbiAgICByZXR1cm4gaGFzaChlbnZlbG9wZSwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBIYXNoZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbShlbnZlbG9wZSwge1xuICogICBzaWduYXR1cmUsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5oYXNoKGVudmVsb3BlX3NpZ25lZCkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIEVJUC0yOTMwIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIGhhc2guXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHByZXNpZ24gfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KHNlcmlhbGl6ZSh7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICAuLi4ocHJlc2lnblxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB5UGFyaXR5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgfSkpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIC4uLiBzZW5kIGBzZXJpYWxpemVkYCB0cmFuc2FjdGlvbiB0byBKU09OLVJQQyBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXMsIGRhdGEsIGlucHV0LCBub25jZSwgdG8sIHZhbHVlLCBhY2Nlc3NMaXN0LCBnYXNQcmljZSB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBjb25zdCBhY2Nlc3NUdXBsZUxpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KG9wdGlvbnMuc2lnbmF0dXJlIHx8IGVudmVsb3BlKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gW1xuICAgICAgICBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBnYXNQcmljZSA/IEhleC5mcm9tTnVtYmVyKGdhc1ByaWNlKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gaW5wdXQgPz8gJzB4JyxcbiAgICAgICAgYWNjZXNzVHVwbGVMaXN0LFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvVHVwbGUoc2lnbmF0dXJlKSA6IFtdKSxcbiAgICBdO1xuICAgIHJldHVybiBIZXguY29uY2F0KCcweDAxJywgUmxwLmZyb21IZXgoc2VyaWFsaXplZCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMjAnKSxcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTI5MzAgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgRUlQLTI5MzAgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhlbnZlbG9wZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGVudmVsb3BlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZCksXG4gICAgICAgIGRhdGE6IGVudmVsb3BlLmRhdGEgPz8gZW52ZWxvcGUuaW5wdXQsXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUuZ2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IGdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5ub25jZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBub25jZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubm9uY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLnZhbHVlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IHZhbHVlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS52YWx1ZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUuZ2FzUHJpY2UgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgZ2FzUHJpY2U6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLmdhc1ByaWNlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgdHlwZTogJzB4MScsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5hc3NlcnQoe1xuICogICBnYXNQcmljZTogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5qcy5tYXAiXSwibmFtZXMiOlsiQWNjZXNzTGlzdCIsIkFkZHJlc3MiLCJIYXNoIiwiSGV4IiwiUmxwIiwiU2lnbmF0dXJlIiwiVHJhbnNhY3Rpb25FbnZlbG9wZSIsInNlcmlhbGl6ZWRUeXBlIiwidHlwZSIsImFzc2VydCIsImVudmVsb3BlIiwiY2hhaW5JZCIsImdhc1ByaWNlIiwidG8iLCJJbnZhbGlkQ2hhaW5JZEVycm9yIiwic3RyaWN0IiwiQmlnSW50IiwiR2FzUHJpY2VUb29IaWdoRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0cmFuc2FjdGlvbkFycmF5IiwidG9IZXgiLCJzbGljZSIsIm5vbmNlIiwiZ2FzIiwidmFsdWUiLCJkYXRhIiwiYWNjZXNzTGlzdCIsInlQYXJpdHkiLCJyIiwicyIsImxlbmd0aCIsIkludmFsaWRTZXJpYWxpemVkRXJyb3IiLCJhdHRyaWJ1dGVzIiwidHJhbnNhY3Rpb24iLCJOdW1iZXIiLCJ2YWxpZGF0ZSIsImZyb21UdXBsZUxpc3QiLCJzaWduYXR1cmUiLCJmcm9tVHVwbGUiLCJ1bmRlZmluZWQiLCJmcm9tIiwib3B0aW9ucyIsImVudmVsb3BlXyIsImdldFNpZ25QYXlsb2FkIiwiaGFzaCIsInByZXNpZ24iLCJrZWNjYWsyNTYiLCJzZXJpYWxpemUiLCJ2IiwiaW5wdXQiLCJhY2Nlc3NUdXBsZUxpc3QiLCJ0b1R1cGxlTGlzdCIsImV4dHJhY3QiLCJmcm9tTnVtYmVyIiwidG9UdXBsZSIsImNvbmNhdCIsImZyb21IZXgiLCJ0b1JwYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   deserialize: function() { return /* binding */ deserialize; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   serializedType: function() { return /* binding */ serializedType; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Authorization.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n/* harmony import */ var _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TransactionEnvelopeEip1559.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n\n\n\n\n\n\n\n\n\nconst serializedType = \"0x04\";\nconst type = \"eip7702\";\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * TransactionEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { authorizationList } = envelope;\n    if (authorizationList) {\n        for (const authorization of authorizationList){\n            const { address, chainId } = authorization;\n            if (address) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, {\n                strict: false\n            });\n            if (Number(chainId) < 0) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({\n                chainId\n            });\n        }\n    }\n    _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_2__.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_4__.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, yParity, r, s] = transactionArray;\n    if (!(transactionArray.length === 10 || transactionArray.length === 13)) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n        attributes: {\n            chainId,\n            nonce,\n            maxPriorityFeePerGas,\n            maxFeePerGas,\n            gas,\n            to,\n            value,\n            data,\n            accessList,\n            authorizationList,\n            ...transactionArray.length > 9 ? {\n                yParity,\n                r,\n                s\n            } : {}\n        },\n        serialized,\n        type\n    });\n    let transaction = {\n        chainId: Number(chainId),\n        type\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(to) && to !== \"0x\") transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(data) && data !== \"0x\") transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(nonce) && nonce !== \"0x\") transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(value) && value !== \"0x\") transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(maxFeePerGas) && maxFeePerGas !== \"0x\") transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== \"0x\") transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== \"0x\") transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_5__.fromTupleList(accessList);\n    if (authorizationList !== \"0x\") transaction.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_6__.fromTupleList(authorizationList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.fromTuple([\n        yParity,\n        r,\n        s\n    ]) : undefined;\n    if (signature) transaction = {\n        ...transaction,\n        ...signature\n    };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TransactionEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */ function from(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.from(signature) : {},\n        type: \"eip7702\"\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_8__.keccak256(serialize({\n        ...envelope,\n        ...presign ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined\n        } : {}\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_5__.toTupleList(accessList);\n    const authorizationTupleList = _Authorization_js__WEBPACK_IMPORTED_MODULE_6__.toTupleList(authorizationList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_7__.extract(options.signature || envelope);\n    var _ref;\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(nonce) : \"0x\",\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(maxPriorityFeePerGas) : \"0x\",\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(maxFeePerGas) : \"0x\",\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(gas) : \"0x\",\n        to !== null && to !== void 0 ? to : \"0x\",\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(value) : \"0x\",\n        (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : \"0x\",\n        accessTupleList,\n        authorizationTupleList,\n        ...signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.toTuple(signature) : []\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_4__.concat(serializedType, _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(serialized));\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=TransactionEnvelopeEip7702.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ047QUFDWTtBQUNsQjtBQUNGO0FBQ0E7QUFDWTtBQUNvQjtBQUNjO0FBQ3ZFLE1BQU1TLGlCQUFpQixPQUFPO0FBQzlCLE1BQU1DLE9BQU8sVUFBVTtBQUM5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FDTSxTQUFTQyxPQUFPQyxRQUFRO0lBQzNCLE1BQU0sRUFBRUMsaUJBQWlCLEVBQUUsR0FBR0Q7SUFDOUIsSUFBSUMsbUJBQW1CO1FBQ25CLEtBQUssTUFBTUMsaUJBQWlCRCxrQkFBbUI7WUFDM0MsTUFBTSxFQUFFRSxPQUFPLEVBQUVDLE9BQU8sRUFBRSxHQUFHRjtZQUM3QixJQUFJQyxTQUNBZCwrQ0FBYyxDQUFDYyxTQUFTO2dCQUFFRSxRQUFRO1lBQU07WUFDNUMsSUFBSUMsT0FBT0YsV0FBVyxHQUNsQixNQUFNLElBQUlULHdFQUF1QyxDQUFDO2dCQUFFUztZQUFRO1FBQ3BFO0lBQ0o7SUFDQVIsa0VBQWlDLENBQUNJO0FBQ3RDO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNNLFNBQVNRLFlBQVlDLFVBQVU7SUFDbEMsTUFBTUMsbUJBQW1CakIsMENBQVMsQ0FBQ0QsMENBQVMsQ0FBQ2lCLFlBQVk7SUFDekQsTUFBTSxDQUFDTCxTQUFTUyxPQUFPQyxzQkFBc0JDLGNBQWNDLEtBQUtDLElBQUlDLE9BQU9DLE1BQU1DLFlBQVluQixtQkFBbUJvQixTQUFTQyxHQUFHQyxFQUFHLEdBQUdiO0lBQ2xJLElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCYyxNQUFNLEtBQUssTUFBTWQsaUJBQWlCYyxNQUFNLEtBQUssRUFBQyxHQUNqRSxNQUFNLElBQUk3QiwyRUFBMEMsQ0FBQztRQUNqRCtCLFlBQVk7WUFDUnRCO1lBQ0FTO1lB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TUFBTSxFQUFFbEMsaUJBQWlCLEVBQUVHLE9BQU8sRUFBRVksR0FBRyxFQUFFSCxLQUFLLEVBQUVJLEVBQUUsRUFBRUMsS0FBSyxFQUFFSCxZQUFZLEVBQUVELG9CQUFvQixFQUFFTSxVQUFVLEVBQUVELElBQUksRUFBRXVCLEtBQUssRUFBRyxHQUFHMUM7SUFDNUhELE9BQU9DO0lBQ1AsTUFBTTJDLGtCQUFrQnZELHVEQUFzQixDQUFDZ0M7SUFDL0MsTUFBTXlCLHlCQUF5QnZELDBEQUF5QixDQUFDVztJQUN6RCxNQUFNOEIsWUFBWXJDLGtEQUFpQixDQUFDeUMsUUFBUUosU0FBUyxJQUFJL0I7UUFTckRtQjtJQVJKLE1BQU1WLGFBQWE7UUFDZmpCLCtDQUFjLENBQUNZO1FBQ2ZTLFFBQVFyQiwrQ0FBYyxDQUFDcUIsU0FBUztRQUNoQ0MsdUJBQXVCdEIsK0NBQWMsQ0FBQ3NCLHdCQUF3QjtRQUM5REMsZUFBZXZCLCtDQUFjLENBQUN1QixnQkFBZ0I7UUFDOUNDLE1BQU14QiwrQ0FBYyxDQUFDd0IsT0FBTztRQUM1QkMsZUFBQUEsZ0JBQUFBLEtBQU07UUFDTkMsUUFBUTFCLCtDQUFjLENBQUMwQixTQUFTO1FBQ2hDQyxDQUFBQSxPQUFBQSxpQkFBQUEsa0JBQUFBLE9BQVF1QixtQkFBUnZCLGtCQUFBQSxPQUFpQjtRQUNqQndCO1FBQ0FFO1dBQ0lkLFlBQVlyQyxrREFBaUIsQ0FBQ3FDLGFBQWEsRUFBRTtLQUNwRDtJQUNELE9BQU92QywyQ0FBVSxDQUFDSyxnQkFBZ0JKLDRDQUFXLENBQUNnQjtBQUNsRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDTSxTQUFTbUIsU0FBUzVCLFFBQVE7SUFDN0IsSUFBSTtRQUNBRCxPQUFPQztRQUNQLE9BQU87SUFDWCxFQUNBLFVBQU07UUFDRixPQUFPO0lBQ1g7QUFDSixFQUNBLHNEQUFzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmpzP2I1ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWNjZXNzTGlzdCBmcm9tICcuL0FjY2Vzc0xpc3QuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgQXV0aG9yaXphdGlvbiBmcm9tICcuL0F1dGhvcml6YXRpb24uanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgZnJvbSAnLi9UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5qcyc7XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplZFR5cGUgPSAnMHgwNCc7XG5leHBvcnQgY29uc3QgdHlwZSA9ICdlaXA3NzAyJztcbi8qKlxuICogQXNzZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0gaXMgdmFsaWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5hc3NlcnQoe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogW10sXG4gKiAgIG1heEZlZVBlckdhczogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBlcnJvcjogRmVlQ2FwVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZmVlIGNhcCAoYG1hc0ZlZVBlckdhc2AgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMgZ3dlaSkgY2Fubm90IGJlXG4gKiAvLyBAZXJyb3I6IGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChlbnZlbG9wZSkge1xuICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbkxpc3QgfSA9IGVudmVsb3BlO1xuICAgIGlmIChhdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcywgY2hhaW5JZCB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKVxuICAgICAgICAgICAgICAgIEFkZHJlc3MuYXNzZXJ0KGFkZHJlc3MsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChOdW1iZXIoY2hhaW5JZCkgPCAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3IoeyBjaGFpbklkIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydChlbnZlbG9wZSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0gZnJvbSBpdHMgc2VyaWFsaXplZCBmb3JtLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmRlc2VyaWFsaXplKCcweDA0ZWYwMTgyMDMxMTg0NzczNTk0MDA4NDc3MzU5NDAwODA5NDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5Yzg4ODBkZTBiNmIzYTc2NDAwMDA4MGMwJylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNzcwMicsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA3ODVuLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25BcnJheSA9IFJscC50b0hleChIZXguc2xpY2Uoc2VyaWFsaXplZCwgMSkpO1xuICAgIGNvbnN0IFtjaGFpbklkLCBub25jZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzLCB0bywgdmFsdWUsIGRhdGEsIGFjY2Vzc0xpc3QsIGF1dGhvcml6YXRpb25MaXN0LCB5UGFyaXR5LCByLCBzLF0gPSB0cmFuc2FjdGlvbkFycmF5O1xuICAgIGlmICghKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID09PSAxMCB8fCB0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTMpKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBnYXMsXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBhY2Nlc3NMaXN0LFxuICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb25MaXN0LFxuICAgICAgICAgICAgICAgIC4uLih0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA+IDlcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5UGFyaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VyaWFsaXplZCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgIH0pO1xuICAgIGxldCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgY2hhaW5JZDogTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICB0eXBlLFxuICAgIH07XG4gICAgaWYgKEhleC52YWxpZGF0ZSh0bykgJiYgdG8gIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnRvID0gdG87XG4gICAgaWYgKEhleC52YWxpZGF0ZShnYXMpICYmIGdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gQmlnSW50KGdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShkYXRhKSAmJiBkYXRhICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gZGF0YTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG5vbmNlKSAmJiBub25jZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubm9uY2UgPSBCaWdJbnQobm9uY2UpO1xuICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpICYmIHZhbHVlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi52YWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhGZWVQZXJHYXMpICYmIG1heEZlZVBlckdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID0gQmlnSW50KG1heEZlZVBlckdhcyk7XG4gICAgaWYgKEhleC52YWxpZGF0ZShtYXhQcmlvcml0eUZlZVBlckdhcykgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnSW50KG1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBpZiAoYWNjZXNzTGlzdC5sZW5ndGggIT09IDAgJiYgYWNjZXNzTGlzdCAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IEFjY2Vzc0xpc3QuZnJvbVR1cGxlTGlzdChhY2Nlc3NMaXN0KTtcbiAgICBpZiAoYXV0aG9yaXphdGlvbkxpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmF1dGhvcml6YXRpb25MaXN0ID0gQXV0aG9yaXphdGlvbi5mcm9tVHVwbGVMaXN0KGF1dGhvcml6YXRpb25MaXN0KTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSByICYmIHMgJiYgeVBhcml0eSA/IFNpZ25hdHVyZS5mcm9tVHVwbGUoW3lQYXJpdHksIHIsIHNdKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoc2lnbmF0dXJlKVxuICAgICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgLi4uc2lnbmF0dXJlLFxuICAgICAgICB9O1xuICAgIGFzc2VydCh0cmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcmJpdHJhcnkgdHJhbnNhY3Rpb24gb2JqZWN0IGludG8gYW4gRUlQLTc3MDIgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbiksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb25MaXN0ID0gW0F1dGhvcml6YXRpb24uZnJvbShhdXRob3JpemF0aW9uLCB7IHNpZ25hdHVyZSB9KV1cbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGF1dGhvcml6YXRpb25MaXN0LCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGNoYWluSWQ6IDEsIC8vIFshY29kZSBmb2N1c11cbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIC8vIFshY29kZSBmb2N1c11cbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNzcwMicsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgcjogMTI1Li4ubixcbiAqIC8vIEBsb2c6ICAgczogNjQyLi4ubixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gaW5zdGFudGlhdGUgYW4gRUlQLTc3MDIgVHJhbnNhY3Rpb24gRW52ZWxvcGUgZnJvbSBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5TZXJpYWxpemVkfSB2YWx1ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oJzB4MDRmODU4MDE4MjAzMTE4NTAyNTQwYmU0MDA4NTA0YTgxN2M4MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzA4NDc3MzU5NDAwZTFhMDAxNjI3YzY4NzI2MWIwZTdmODYzOGFmMTExMmVmYThhNzdlMjM2NTZmNmU3OTQ1Mjc1YjE5ZTlkZWVkODAyNjEnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXA3NzAyJyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIG9iamVjdCB0byBjb252ZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgQW4gRUlQLTc3MDIgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBlbnZlbG9wZV8gPSAodHlwZW9mIGVudmVsb3BlID09PSAnc3RyaW5nJyA/IGRlc2VyaWFsaXplKGVudmVsb3BlKSA6IGVudmVsb3BlKTtcbiAgICBhc3NlcnQoZW52ZWxvcGVfKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZV8sXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUuZnJvbShzaWduYXR1cmUpIDoge30pLFxuICAgICAgICB0eXBlOiAnZWlwNzcwMicsXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGF5bG9hZCB0byBzaWduIGZvciBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBob3cgdG8gY29tcHV0ZSB0aGUgc2lnbiBwYXlsb2FkIHdoaWNoIGNhbiBiZSB1c2VkXG4gKiB3aXRoIEVDRFNBIHNpZ25pbmcgdXRpbGl0aWVzIGxpa2Uge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIHtcbiAgICByZXR1cm4gaGFzaChlbnZlbG9wZSwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBIYXNoZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDJ9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmhhc2goZW52ZWxvcGVfc2lnbmVkKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTc3MDIgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH0pKTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBbQXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pXVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0LFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLnNlcmlhbGl6ZShlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogICBjaGFpbklkOiAxLFxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5zZXJpYWxpemUoZW52ZWxvcGUsIHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqXG4gKiAvLyAuLi4gc2VuZCBgc2VyaWFsaXplZGAgdHJhbnNhY3Rpb24gdG8gSlNPTi1SUEMgYGV0aF9zZW5kUmF3VHJhbnNhY3Rpb25gXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gc2VyaWFsaXplLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXV0aG9yaXphdGlvbkxpc3QsIGNoYWluSWQsIGdhcywgbm9uY2UsIHRvLCB2YWx1ZSwgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywgYWNjZXNzTGlzdCwgZGF0YSwgaW5wdXQsIH0gPSBlbnZlbG9wZTtcbiAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgIGNvbnN0IGFjY2Vzc1R1cGxlTGlzdCA9IEFjY2Vzc0xpc3QudG9UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvblR1cGxlTGlzdCA9IEF1dGhvcml6YXRpb24udG9UdXBsZUxpc3QoYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KG9wdGlvbnMuc2lnbmF0dXJlIHx8IGVudmVsb3BlKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gW1xuICAgICAgICBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heFByaW9yaXR5RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIG1heEZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heEZlZVBlckdhcykgOiAnMHgnLFxuICAgICAgICBnYXMgPyBIZXguZnJvbU51bWJlcihnYXMpIDogJzB4JyxcbiAgICAgICAgdG8gPz8gJzB4JyxcbiAgICAgICAgdmFsdWUgPyBIZXguZnJvbU51bWJlcih2YWx1ZSkgOiAnMHgnLFxuICAgICAgICBkYXRhID8/IGlucHV0ID8/ICcweCcsXG4gICAgICAgIGFjY2Vzc1R1cGxlTGlzdCxcbiAgICAgICAgYXV0aG9yaXphdGlvblR1cGxlTGlzdCxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1R1cGxlKHNpZ25hdHVyZSkgOiBbXSksXG4gICAgXTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChzZXJpYWxpemVkVHlwZSwgUmxwLmZyb21IZXgoc2VyaWFsaXplZCkpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDJ9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi52YWxpZGF0ZSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0OiBbXSxcbiAqICAgbWF4RmVlUGVyR2FzOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byB2YWxpZGF0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKGVudmVsb3BlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmpzLm1hcCJdLCJuYW1lcyI6WyJBY2Nlc3NMaXN0IiwiQWRkcmVzcyIsIkF1dGhvcml6YXRpb24iLCJIYXNoIiwiSGV4IiwiUmxwIiwiU2lnbmF0dXJlIiwiVHJhbnNhY3Rpb25FbnZlbG9wZSIsIlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5Iiwic2VyaWFsaXplZFR5cGUiLCJ0eXBlIiwiYXNzZXJ0IiwiZW52ZWxvcGUiLCJhdXRob3JpemF0aW9uTGlzdCIsImF1dGhvcml6YXRpb24iLCJhZGRyZXNzIiwiY2hhaW5JZCIsInN0cmljdCIsIk51bWJlciIsIkludmFsaWRDaGFpbklkRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0cmFuc2FjdGlvbkFycmF5IiwidG9IZXgiLCJzbGljZSIsIm5vbmNlIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJtYXhGZWVQZXJHYXMiLCJnYXMiLCJ0byIsInZhbHVlIiwiZGF0YSIsImFjY2Vzc0xpc3QiLCJ5UGFyaXR5IiwiciIsInMiLCJsZW5ndGgiLCJJbnZhbGlkU2VyaWFsaXplZEVycm9yIiwiYXR0cmlidXRlcyIsInRyYW5zYWN0aW9uIiwidmFsaWRhdGUiLCJCaWdJbnQiLCJmcm9tVHVwbGVMaXN0Iiwic2lnbmF0dXJlIiwiZnJvbVR1cGxlIiwidW5kZWZpbmVkIiwiZnJvbSIsIm9wdGlvbnMiLCJlbnZlbG9wZV8iLCJnZXRTaWduUGF5bG9hZCIsImhhc2giLCJwcmVzaWduIiwia2VjY2FrMjU2Iiwic2VyaWFsaXplIiwiaW5wdXQiLCJhY2Nlc3NUdXBsZUxpc3QiLCJ0b1R1cGxlTGlzdCIsImF1dGhvcml6YXRpb25UdXBsZUxpc3QiLCJleHRyYWN0IiwiZnJvbU51bWJlciIsInRvVHVwbGUiLCJjb25jYXQiLCJmcm9tSGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   deserialize: function() { return /* binding */ deserialize; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   getSignPayload: function() { return /* binding */ getSignPayload; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; },\n/* harmony export */   toRpc: function() { return /* binding */ toRpc; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\nconst type = \"legacy\";\n/**\n * Asserts a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */ function assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (to) _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(to, {\n        strict: false\n    });\n    if (typeof chainId !== \"undefined\" && chainId <= 0) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({\n        chainId\n    });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.GasPriceTooHighError({\n        gasPrice\n    });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */ function deserialize(serialized) {\n    const tuple = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(serialized);\n    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = tuple;\n    if (!(tuple.length === 6 || tuple.length === 9)) throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n        attributes: {\n            nonce,\n            gasPrice,\n            gas,\n            to,\n            value,\n            data,\n            ...tuple.length > 6 ? {\n                v: chainIdOrV_,\n                r,\n                s\n            } : {}\n        },\n        serialized,\n        type\n    });\n    const transaction = {\n        type\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== \"0x\") transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== \"0x\") transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== \"0x\") transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== \"0x\") transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== \"0x\") transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gasPrice) && gasPrice !== \"0x\") transaction.gasPrice = BigInt(gasPrice);\n    if (tuple.length === 6) return transaction;\n    const chainIdOrV = _Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(chainIdOrV_) && chainIdOrV_ !== \"0x\" ? Number(chainIdOrV_) : 0;\n    if (s === \"0x\" && r === \"0x\") {\n        if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV);\n        return transaction;\n    }\n    const v = chainIdOrV;\n    const chainId = Math.floor((v - 35) / 2);\n    if (chainId > 0) transaction.chainId = chainId;\n    else if (v !== 27 && v !== 28) throw new _Signature_js__WEBPACK_IMPORTED_MODULE_4__.InvalidVError({\n        value: v\n    });\n    transaction.yParity = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.vToYParity(v);\n    transaction.v = v;\n    transaction.s = s === \"0x\" ? 0n : BigInt(s);\n    transaction.r = r === \"0x\" ? 0n : BigInt(r);\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TransactionEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */ function from(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { signature } = options;\n    const envelope_ = typeof envelope === \"string\" ? deserialize(envelope) : envelope;\n    assert(envelope_);\n    const signature_ = (()=>{\n        if (!signature) return {};\n        const s = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.from(signature);\n        s.v = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(s.yParity);\n        return s;\n    })();\n    return {\n        ...envelope_,\n        ...signature_,\n        type: \"legacy\"\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */ function getSignPayload(envelope) {\n    return hash(envelope, {\n        presign: true\n    });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */ function hash(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_5__.keccak256(serialize({\n        ...envelope,\n        ...presign ? {\n            r: undefined,\n            s: undefined,\n            yParity: undefined,\n            v: undefined\n        } : {}\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */ function serialize(envelope) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const { chainId = 0, gas, data, input, nonce, to, value, gasPrice } = envelope;\n    assert(envelope);\n    var _ref;\n    let serialized = [\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : \"0x\",\n        gasPrice ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gasPrice) : \"0x\",\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : \"0x\",\n        to !== null && to !== void 0 ? to : \"0x\",\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : \"0x\",\n        (_ref = data !== null && data !== void 0 ? data : input) !== null && _ref !== void 0 ? _ref : \"0x\"\n    ];\n    const signature = (()=>{\n        if (options.signature) return {\n            r: options.signature.r,\n            s: options.signature.s,\n            v: _Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(options.signature.yParity)\n        };\n        if (typeof envelope.r === \"undefined\" || typeof envelope.s === \"undefined\") return undefined;\n        return {\n            r: envelope.r,\n            s: envelope.s,\n            v: envelope.v\n        };\n    })();\n    if (signature) {\n        const v = (()=>{\n            // EIP-155 (inferred chainId)\n            if (signature.v >= 35) {\n                const inferredChainId = Math.floor((signature.v - 35) / 2);\n                if (inferredChainId > 0) return signature.v;\n                return 27 + (signature.v === 35 ? 0 : 1);\n            }\n            // EIP-155 (explicit chainId)\n            if (chainId > 0) return chainId * 2 + 35 + signature.v - 27;\n            // Pre-EIP-155 (no chainId)\n            const v = 27 + (signature.v === 27 ? 0 : 1);\n            if (signature.v !== v) throw new _Signature_js__WEBPACK_IMPORTED_MODULE_4__.InvalidVError({\n                value: signature.v\n            });\n            return v;\n        })();\n        serialized = [\n            ...serialized,\n            _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(v),\n            signature.r === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(signature.r)),\n            signature.s === 0n ? \"0x\" : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(signature.s))\n        ];\n    } else if (chainId > 0) serialized = [\n        ...serialized,\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        \"0x\",\n        \"0x\"\n    ];\n    return _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized);\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} to an {@link ox#TransactionEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */ function toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.extract(envelope);\n    var _envelope_data;\n    return {\n        ...envelope,\n        chainId: typeof envelope.chainId === \"number\" ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId) : undefined,\n        data: (_envelope_data = envelope.data) !== null && _envelope_data !== void 0 ? _envelope_data : envelope.input,\n        type: \"0x0\",\n        ...typeof envelope.gas === \"bigint\" ? {\n            gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas)\n        } : {},\n        ...typeof envelope.nonce === \"bigint\" ? {\n            nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce)\n        } : {},\n        ...typeof envelope.value === \"bigint\" ? {\n            value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value)\n        } : {},\n        ...typeof envelope.gasPrice === \"bigint\" ? {\n            gasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gasPrice)\n        } : {},\n        ...signature ? {\n            ..._Signature_js__WEBPACK_IMPORTED_MODULE_4__.toRpc(signature),\n            v: signature.yParity === 0 ? \"0x1b\" : \"0x1c\"\n        } : {}\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */ function validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    } catch (e) {\n        return false;\n    }\n} //# sourceMappingURL=TransactionEnvelopeLegacy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDTjtBQUNGO0FBQ0E7QUFDWTtBQUNvQjtBQUN6RCxNQUFNTSxPQUFPLFNBQVM7QUFDN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDTSxTQUFTQyxPQUFPQyxRQUFRO0lBQzNCLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLEVBQUUsRUFBRSxHQUFHSDtJQUNsQyxJQUFJRyxJQUNBWCwrQ0FBYyxDQUFDVyxJQUFJO1FBQUVDLFFBQVE7SUFBTTtJQUN2QyxJQUFJLE9BQU9ILFlBQVksZUFBZUEsV0FBVyxHQUM3QyxNQUFNLElBQUlKLHdFQUF1QyxDQUFDO1FBQUVJO0lBQVE7SUFDaEUsSUFBSUMsWUFBWUksT0FBT0osWUFBWSxFQUFFLElBQUksSUFBSSxHQUFHLEVBQUUsRUFDOUMsTUFBTSxJQUFJTCx5RUFBd0MsQ0FBQztRQUFFSztJQUFTO0FBQ3RFO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ00sU0FBU00sWUFBWUMsVUFBVTtJQUNsQyxNQUFNQyxRQUFRZiwwQ0FBUyxDQUFDYztJQUN4QixNQUFNLENBQUNHLE9BQU9WLFVBQVVXLEtBQUtWLElBQUlXLE9BQU9DLE1BQU1DLGFBQWFDLEdBQUdDLEVBQUUsR0FBR1I7SUFDbkUsSUFBSSxDQUFFQSxDQUFBQSxNQUFNUyxNQUFNLEtBQUssS0FBS1QsTUFBTVMsTUFBTSxLQUFLLElBQ3pDLE1BQU0sSUFBSXRCLDJFQUEwQyxDQUFDO1FBQ2pEd0IsWUFBWTtZQUNSVDtZQUNBVjtZQUNBVztZQUNBVjtZQUNBVztZQUNBQztZQUNBLEdBQUlMLE1BQU1TLE1BQU0sR0FBRyxJQUNiO2dCQUNFRyxHQUFHTjtnQkFDSEM7Z0JBQ0FDO1lBQ0osSUFDRSxDQUFDLENBQUM7UUFDWjtRQUNB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UUFDWEMsU0FBUyxPQUFPRCxTQUFTQyxPQUFPLEtBQUssV0FDL0JQLCtDQUFjLENBQUNNLFNBQVNDLE9BQU8sSUFDL0IwQztRQUNONUIsTUFBTWYsQ0FBQUEsaUJBQUFBLFNBQVNlLElBQUksY0FBYmYsNEJBQUFBLGlCQUFpQkEsU0FBUzRDLEtBQUs7UUFDckM5QyxNQUFNO1FBQ04sR0FBSSxPQUFPRSxTQUFTYSxHQUFHLEtBQUssV0FDdEI7WUFBRUEsS0FBS25CLCtDQUFjLENBQUNNLFNBQVNhLEdBQUc7UUFBRSxJQUNwQyxDQUFDLENBQUM7UUFDUixHQUFJLE9BQU9iLFNBQVNZLEtBQUssS0FBSyxXQUN4QjtZQUFFQSxPQUFPbEIsK0NBQWMsQ0FBQ00sU0FBU1ksS0FBSztRQUFFLElBQ3hDLENBQUMsQ0FBQztRQUNSLEdBQUksT0FBT1osU0FBU2MsS0FBSyxLQUFLLFdBQ3hCO1lBQUVBLE9BQU9wQiwrQ0FBYyxDQUFDTSxTQUFTYyxLQUFLO1FBQUUsSUFDeEMsQ0FBQyxDQUFDO1FBQ1IsR0FBSSxPQUFPZCxTQUFTRSxRQUFRLEtBQUssV0FDM0I7WUFBRUEsVUFBVVIsK0NBQWMsQ0FBQ00sU0FBU0UsUUFBUTtRQUFFLElBQzlDLENBQUMsQ0FBQztRQUNSLEdBQUlnQyxZQUNFO1lBQ0UsR0FBR3RDLGdEQUFlLENBQUNzQyxVQUFVO1lBQzdCWixHQUFHWSxVQUFVSixPQUFPLEtBQUssSUFBSSxTQUFTO1FBQzFDLElBQ0UsQ0FBQyxDQUFDO0lBQ1o7QUFDSjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztDQWlCQyxHQUNNLFNBQVNOLFNBQVN4QixRQUFRO0lBQzdCLElBQUk7UUFDQUQsT0FBT0M7UUFDUCxPQUFPO0lBQ1gsRUFDQSxVQUFNO1FBQ0YsT0FBTztJQUNYO0FBQ0osRUFDQSxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmpzPzc0OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuZXhwb3J0IGNvbnN0IHR5cGUgPSAnbGVnYWN5Jztcbi8qKlxuICogQXNzZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmFzc2VydCh7XG4gKiAgIGdhc1ByaWNlOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogLy8gQGVycm9yOiBHYXNQcmljZVRvb0hpZ2hFcnJvcjpcbiAqIC8vIEBlcnJvcjogVGhlIGdhcyBwcmljZSAoYGdhc1ByaWNlYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMyBnd2VpKSBjYW5ub3QgYmVcbiAqIC8vIEBlcnJvcjogaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGVudmVsb3BlKSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXNQcmljZSwgdG8gfSA9IGVudmVsb3BlO1xuICAgIGlmICh0bylcbiAgICAgICAgQWRkcmVzcy5hc3NlcnQodG8sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBpZiAodHlwZW9mIGNoYWluSWQgIT09ICd1bmRlZmluZWQnICYmIGNoYWluSWQgPD0gMClcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gICAgaWYgKGdhc1ByaWNlICYmIEJpZ0ludChnYXNQcmljZSkgPiAybiAqKiAyNTZuIC0gMW4pXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkdhc1ByaWNlVG9vSGlnaEVycm9yKHsgZ2FzUHJpY2UgfSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9IGZyb20gaXRzIHNlcmlhbGl6ZWQgZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZGVzZXJpYWxpemUoJzB4MDFlZjAxODIwMzExODQ3NzM1OTQwMDg0NzczNTk0MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzAnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICB0eXBlOiAnbGVnYWN5JyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAyMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgZ2FzOiAxMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHR1cGxlID0gUmxwLnRvSGV4KHNlcmlhbGl6ZWQpO1xuICAgIGNvbnN0IFtub25jZSwgZ2FzUHJpY2UsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBjaGFpbklkT3JWXywgciwgc10gPSB0dXBsZTtcbiAgICBpZiAoISh0dXBsZS5sZW5ndGggPT09IDYgfHwgdHVwbGUubGVuZ3RoID09PSA5KSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgLi4uKHR1cGxlLmxlbmd0aCA+IDZcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2OiBjaGFpbklkT3JWXyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdHlwZSxcbiAgICB9O1xuICAgIGlmIChIZXgudmFsaWRhdGUodG8pICYmIHRvICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHRvO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzKSAmJiBnYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhcyA9IEJpZ0ludChnYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZGF0YSkgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkgJiYgbm9uY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzUHJpY2UpICYmIGdhc1ByaWNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXNQcmljZSA9IEJpZ0ludChnYXNQcmljZSk7XG4gICAgaWYgKHR1cGxlLmxlbmd0aCA9PT0gNilcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IGNoYWluSWRPclYgPSBIZXgudmFsaWRhdGUoY2hhaW5JZE9yVl8pICYmIGNoYWluSWRPclZfICE9PSAnMHgnXG4gICAgICAgID8gTnVtYmVyKGNoYWluSWRPclZfKVxuICAgICAgICA6IDA7XG4gICAgaWYgKHMgPT09ICcweCcgJiYgciA9PT0gJzB4Jykge1xuICAgICAgICBpZiAoY2hhaW5JZE9yViA+IDApXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5jaGFpbklkID0gTnVtYmVyKGNoYWluSWRPclYpO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfVxuICAgIGNvbnN0IHYgPSBjaGFpbklkT3JWO1xuICAgIGNvbnN0IGNoYWluSWQgPSBNYXRoLmZsb29yKCh2IC0gMzUpIC8gMik7XG4gICAgaWYgKGNoYWluSWQgPiAwKVxuICAgICAgICB0cmFuc2FjdGlvbi5jaGFpbklkID0gY2hhaW5JZDtcbiAgICBlbHNlIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOClcbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZS5JbnZhbGlkVkVycm9yKHsgdmFsdWU6IHYgfSk7XG4gICAgdHJhbnNhY3Rpb24ueVBhcml0eSA9IFNpZ25hdHVyZS52VG9ZUGFyaXR5KHYpO1xuICAgIHRyYW5zYWN0aW9uLnYgPSB2O1xuICAgIHRyYW5zYWN0aW9uLnMgPSBzID09PSAnMHgnID8gMG4gOiBCaWdJbnQocyk7XG4gICAgdHJhbnNhY3Rpb24uciA9IHIgPT09ICcweCcgPyAwbiA6IEJpZ0ludChyKTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGEgbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNzcwMicsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgcjogMTI1Li4ubixcbiAqIC8vIEBsb2c6ICAgczogNjQyLi4ubixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gaW5zdGFudGlhdGUgYW4gbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlIGZyb20gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5TZXJpYWxpemVkfSB2YWx1ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKCcweGY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2xlZ2FjeScsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEEgbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICghc2lnbmF0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICBjb25zdCBzID0gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKTtcbiAgICAgICAgcy52ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1Yocy55UGFyaXR5KTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZV8sXG4gICAgICAgIC4uLnNpZ25hdHVyZV8sXG4gICAgICAgIHR5cGU6ICdsZWdhY3knLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oe1xuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGdldCB0aGUgc2lnbiBwYXlsb2FkIGZvci5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChlbnZlbG9wZSkge1xuICAgIHJldHVybiBoYXNoKGVudmVsb3BlLCB7IHByZXNpZ246IHRydWUgfSk7XG59XG4vKipcbiAqIEhhc2hlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXNQcmljZTogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJ1xuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBMZWdhY3kgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gLi4uIHNlbmQgYHNlcmlhbGl6ZWRgIHRyYW5zYWN0aW9uIHRvIEpTT04tUlBDIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYFxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoYWluSWQgPSAwLCBnYXMsIGRhdGEsIGlucHV0LCBub25jZSwgdG8sIHZhbHVlLCBnYXNQcmljZSB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBsZXQgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBnYXNQcmljZSA/IEhleC5mcm9tTnVtYmVyKGdhc1ByaWNlKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gaW5wdXQgPz8gJzB4JyxcbiAgICBdO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hdHVyZSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcjogb3B0aW9ucy5zaWduYXR1cmUucixcbiAgICAgICAgICAgICAgICBzOiBvcHRpb25zLnNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgICAgIHY6IFNpZ25hdHVyZS55UGFyaXR5VG9WKG9wdGlvbnMuc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnZlbG9wZS5yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZW52ZWxvcGUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogZW52ZWxvcGUucixcbiAgICAgICAgICAgIHM6IGVudmVsb3BlLnMsXG4gICAgICAgICAgICB2OiBlbnZlbG9wZS52LFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCB2ID0gKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEVJUC0xNTUgKGluZmVycmVkIGNoYWluSWQpXG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlLnYgPj0gMzUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZlcnJlZENoYWluSWQgPSBNYXRoLmZsb29yKChzaWduYXR1cmUudiAtIDM1KSAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZlcnJlZENoYWluSWQgPiAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlLnY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI3ICsgKHNpZ25hdHVyZS52ID09PSAzNSA/IDAgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVJUC0xNTUgKGV4cGxpY2l0IGNoYWluSWQpXG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluSWQgKiAyICsgMzUgKyBzaWduYXR1cmUudiAtIDI3O1xuICAgICAgICAgICAgLy8gUHJlLUVJUC0xNTUgKG5vIGNoYWluSWQpXG4gICAgICAgICAgICBjb25zdCB2ID0gMjcgKyAoc2lnbmF0dXJlLnYgPT09IDI3ID8gMCA6IDEpO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZS52ICE9PSB2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTaWduYXR1cmUuSW52YWxpZFZFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUudiB9KTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KSgpO1xuICAgICAgICBzZXJpYWxpemVkID0gW1xuICAgICAgICAgICAgLi4uc2VyaWFsaXplZCxcbiAgICAgICAgICAgIEhleC5mcm9tTnVtYmVyKHYpLFxuICAgICAgICAgICAgc2lnbmF0dXJlLnIgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzaWduYXR1cmUucikpLFxuICAgICAgICAgICAgc2lnbmF0dXJlLnMgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzaWduYXR1cmUucykpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFpbklkID4gMClcbiAgICAgICAgc2VyaWFsaXplZCA9IFsuLi5zZXJpYWxpemVkLCBIZXguZnJvbU51bWJlcihjaGFpbklkKSwgJzB4JywgJzB4J107XG4gICAgcmV0dXJuIFJscC5mcm9tSGV4KHNlcmlhbGl6ZWQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fSB0byBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9ycGMgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgbGVnYWN5IHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGVudmVsb3BlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoZW52ZWxvcGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICBjaGFpbklkOiB0eXBlb2YgZW52ZWxvcGUuY2hhaW5JZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBkYXRhOiBlbnZlbG9wZS5kYXRhID8/IGVudmVsb3BlLmlucHV0LFxuICAgICAgICB0eXBlOiAnMHgwJyxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5nYXMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgZ2FzOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5nYXMpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLm5vbmNlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IG5vbmNlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5ub25jZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUudmFsdWUgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgdmFsdWU6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLnZhbHVlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5nYXNQcmljZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBnYXNQcmljZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzUHJpY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4oc2lnbmF0dXJlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgICAgICB2OiBzaWduYXR1cmUueVBhcml0eSA9PT0gMCA/ICcweDFiJyA6ICcweDFjJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoZW52ZWxvcGUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5qcy5tYXAiXSwibmFtZXMiOlsiQWRkcmVzcyIsIkhhc2giLCJIZXgiLCJSbHAiLCJTaWduYXR1cmUiLCJUcmFuc2FjdGlvbkVudmVsb3BlIiwidHlwZSIsImFzc2VydCIsImVudmVsb3BlIiwiY2hhaW5JZCIsImdhc1ByaWNlIiwidG8iLCJzdHJpY3QiLCJJbnZhbGlkQ2hhaW5JZEVycm9yIiwiQmlnSW50IiwiR2FzUHJpY2VUb29IaWdoRXJyb3IiLCJkZXNlcmlhbGl6ZSIsInNlcmlhbGl6ZWQiLCJ0dXBsZSIsInRvSGV4Iiwibm9uY2UiLCJnYXMiLCJ2YWx1ZSIsImRhdGEiLCJjaGFpbklkT3JWXyIsInIiLCJzIiwibGVuZ3RoIiwiSW52YWxpZFNlcmlhbGl6ZWRFcnJvciIsImF0dHJpYnV0ZXMiLCJ2IiwidHJhbnNhY3Rpb24iLCJ2YWxpZGF0ZSIsImNoYWluSWRPclYiLCJOdW1iZXIiLCJNYXRoIiwiZmxvb3IiLCJJbnZhbGlkVkVycm9yIiwieVBhcml0eSIsInZUb1lQYXJpdHkiLCJmcm9tIiwib3B0aW9ucyIsInNpZ25hdHVyZSIsImVudmVsb3BlXyIsInNpZ25hdHVyZV8iLCJ5UGFyaXR5VG9WIiwiZ2V0U2lnblBheWxvYWQiLCJoYXNoIiwicHJlc2lnbiIsImtlY2NhazI1NiIsInNlcmlhbGl6ZSIsInVuZGVmaW5lZCIsImlucHV0IiwiZnJvbU51bWJlciIsImluZmVycmVkQ2hhaW5JZCIsInRyaW1MZWZ0IiwiZnJvbUhleCIsInRvUnBjIiwiZXh0cmFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Value.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Value.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidDecimalNumberError: function() { return /* binding */ InvalidDecimalNumberError; },\n/* harmony export */   exponents: function() { return /* binding */ exponents; },\n/* harmony export */   format: function() { return /* binding */ format; },\n/* harmony export */   formatEther: function() { return /* binding */ formatEther; },\n/* harmony export */   formatGwei: function() { return /* binding */ formatGwei; },\n/* harmony export */   from: function() { return /* binding */ from; },\n/* harmony export */   fromEther: function() { return /* binding */ fromEther; },\n/* harmony export */   fromGwei: function() { return /* binding */ fromGwei; }\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */ const exponents = {\n    wei: 0,\n    gwei: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18\n};\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */ function format(value) {\n    let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    let display = value.toString();\n    const negative = display.startsWith(\"-\");\n    if (negative) display = display.slice(1);\n    display = display.padStart(decimals, \"0\");\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals)\n    ];\n    fraction = fraction.replace(/(0+)$/, \"\");\n    return \"\".concat(negative ? \"-\" : \"\").concat(integer || \"0\").concat(fraction ? \".\".concat(fraction) : \"\");\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */ function formatEther(wei) {\n    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"wei\";\n    return format(wei, exponents.ether - exponents[unit]);\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */ function formatGwei(wei) {\n    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"wei\";\n    return format(wei, exponents.gwei - exponents[unit]);\n}\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */ function from(value) {\n    let decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value)) throw new InvalidDecimalNumberError({\n        value\n    });\n    let [integer = \"\", fraction = \"0\"] = value.split(\".\");\n    const negative = integer.startsWith(\"-\");\n    if (negative) integer = integer.slice(1);\n    // trim trailing zeros.\n    fraction = fraction.replace(/(0+)$/, \"\");\n    // round off if the fraction is larger than the number of decimals.\n    if (decimals === 0) {\n        if (Math.round(Number(\".\".concat(fraction))) === 1) integer = \"\".concat(BigInt(integer) + 1n);\n        fraction = \"\";\n    } else if (fraction.length > decimals) {\n        const [left, unit, right] = [\n            fraction.slice(0, decimals - 1),\n            fraction.slice(decimals - 1, decimals),\n            fraction.slice(decimals)\n        ];\n        const rounded = Math.round(Number(\"\".concat(unit, \".\").concat(right)));\n        if (rounded > 9) fraction = \"\".concat(BigInt(left) + BigInt(1), \"0\").padStart(left.length + 1, \"0\");\n        else fraction = \"\".concat(left).concat(rounded);\n        if (fraction.length > decimals) {\n            fraction = fraction.slice(1);\n            integer = \"\".concat(BigInt(integer) + 1n);\n        }\n        fraction = fraction.slice(0, decimals);\n    } else {\n        fraction = fraction.padEnd(decimals, \"0\");\n    }\n    return BigInt(\"\".concat(negative ? \"-\" : \"\").concat(integer).concat(fraction));\n}\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */ function fromEther(ether) {\n    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"wei\";\n    return from(ether, exponents.ether - exponents[unit]);\n}\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */ function fromGwei(gwei) {\n    let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"wei\";\n    return from(gwei, exponents.gwei - exponents[unit]);\n}\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */ class InvalidDecimalNumberError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ value }){\n        super(\"Value `\".concat(value, \"` is not a valid decimal number.\"));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"Value.InvalidDecimalNumberError\"\n        });\n    }\n} //# sourceMappingURL=Value.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ3RDLDBEQUEwRCxHQUNuRCxNQUFNQyxZQUFZO0lBQ3JCQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLE9BQU87QUFDWCxFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTQyxPQUFPQyxLQUFLO1FBQUVDLFdBQUFBLGlFQUFXO0lBQ3JDLElBQUlDLFVBQVVGLE1BQU1HLFFBQVE7SUFDNUIsTUFBTUMsV0FBV0YsUUFBUUcsVUFBVSxDQUFDO0lBQ3BDLElBQUlELFVBQ0FGLFVBQVVBLFFBQVFJLEtBQUssQ0FBQztJQUM1QkosVUFBVUEsUUFBUUssUUFBUSxDQUFDTixVQUFVO0lBQ3JDLElBQUksQ0FBQ08sU0FBU0MsU0FBUyxHQUFHO1FBQ3RCUCxRQUFRSSxLQUFLLENBQUMsR0FBR0osUUFBUVEsTUFBTSxHQUFHVDtRQUNsQ0MsUUFBUUksS0FBSyxDQUFDSixRQUFRUSxNQUFNLEdBQUdUO0tBQ2xDO0lBQ0RRLFdBQVdBLFNBQVNFLE9BQU8sQ0FBQyxTQUFTO0lBQ3JDLE9BQU8sR0FBeUJILE9BQXRCSixXQUFXLE1BQU0sSUFBc0JLLE9BQWpCRCxXQUFXLEtBQXFDLE9BQS9CQyxXQUFXLElBQWEsT0FBVEEsWUFBYTtBQUNqRjtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0csWUFBWWxCLEdBQUc7UUFBRW1CLE9BQUFBLGlFQUFPO0lBQ3BDLE9BQU9kLE9BQU9MLEtBQUtELFVBQVVLLEtBQUssR0FBR0wsU0FBUyxDQUFDb0IsS0FBSztBQUN4RDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0MsV0FBV3BCLEdBQUc7UUFBRW1CLE9BQUFBLGlFQUFPO0lBQ25DLE9BQU9kLE9BQU9MLEtBQUtELFVBQVVFLElBQUksR0FBR0YsU0FBUyxDQUFDb0IsS0FBSztBQUN2RDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU0UsS0FBS2YsS0FBSztRQUFFQyxXQUFBQSxpRUFBVztJQUNuQyxJQUFJLENBQUMsNEJBQTRCZSxJQUFJLENBQUNoQixRQUNsQyxNQUFNLElBQUlpQiwwQkFBMEI7UUFBRWpCO0lBQU07SUFDaEQsSUFBSSxDQUFDUSxVQUFVLEVBQUUsRUFBRUMsV0FBVyxHQUFHLENBQUMsR0FBR1QsTUFBTWtCLEtBQUssQ0FBQztJQUNqRCxNQUFNZCxXQUFXSSxRQUFRSCxVQUFVLENBQUM7SUFDcEMsSUFBSUQsVUFDQUksVUFBVUEsUUFBUUYsS0FBSyxDQUFDO0lBQzVCLHVCQUF1QjtJQUN2QkcsV0FBV0EsU0FBU0UsT0FBTyxDQUFDLFNBQVM7SUFDckMsbUVBQW1FO0lBQ25FLElBQUlWLGFBQWEsR0FBRztRQUNoQixJQUFJa0IsS0FBS0MsS0FBSyxDQUFDQyxPQUFPLElBQWEsT0FBVFosZ0JBQWlCLEdBQ3ZDRCxVQUFVLEdBQXdCLE9BQXJCYyxPQUFPZCxXQUFXLEVBQUU7UUFDckNDLFdBQVc7SUFDZixPQUNLLElBQUlBLFNBQVNDLE1BQU0sR0FBR1QsVUFBVTtRQUNqQyxNQUFNLENBQUNzQixNQUFNVixNQUFNVyxNQUFNLEdBQUc7WUFDeEJmLFNBQVNILEtBQUssQ0FBQyxHQUFHTCxXQUFXO1lBQzdCUSxTQUFTSCxLQUFLLENBQUNMLFdBQVcsR0FBR0E7WUFDN0JRLFNBQVNILEtBQUssQ0FBQ0w7U0FDbEI7UUFDRCxNQUFNd0IsVUFBVU4sS0FBS0MsS0FBSyxDQUFDQyxPQUFPLEdBQVdHLE9BQVJYLE1BQUssS0FBUyxPQUFOVztRQUM3QyxJQUFJQyxVQUFVLEdBQ1ZoQixXQUFXLEdBQTRCLE9BQXpCYSxPQUFPQyxRQUFRRCxPQUFPLElBQUcsS0FBR2YsUUFBUSxDQUFDZ0IsS0FBS2IsTUFBTSxHQUFHLEdBQUc7YUFFcEVELFdBQVcsR0FBVWdCLE9BQVBGLE1BQWUsT0FBUkU7UUFDekIsSUFBSWhCLFNBQVNDLE1BQU0sR0FBR1QsVUFBVTtZQUM1QlEsV0FBV0EsU0FBU0gsS0FBSyxDQUFDO1lBQzFCRSxVQUFVLEdBQXdCLE9BQXJCYyxPQUFPZCxXQUFXLEVBQUU7UUFDckM7UUFDQUMsV0FBV0EsU0FBU0gsS0FBSyxDQUFDLEdBQUdMO0lBQ2pDLE9BQ0s7UUFDRFEsV0FBV0EsU0FBU2lCLE1BQU0sQ0FBQ3pCLFVBQVU7SUFDekM7SUFDQSxPQUFPcUIsT0FBTyxHQUF5QmQsT0FBdEJKLFdBQVcsTUFBTSxJQUFlSyxPQUFWRCxTQUFtQixPQUFUQztBQUNyRDtBQUNBOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ00sU0FBU2tCLFVBQVU3QixLQUFLO1FBQUVlLE9BQUFBLGlFQUFPO0lBQ3BDLE9BQU9FLEtBQUtqQixPQUFPTCxVQUFVSyxLQUFLLEdBQUdMLFNBQVMsQ0FBQ29CLEtBQUs7QUFDeEQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNNLFNBQVNlLFNBQVNqQyxJQUFJO1FBQUVrQixPQUFBQSxpRUFBTztJQUNsQyxPQUFPRSxLQUFLcEIsTUFBTUYsVUFBVUUsSUFBSSxHQUFHRixTQUFTLENBQUNvQixLQUFLO0FBQ3REO0FBQ0E7Ozs7Ozs7Ozs7Q0FVQyxHQUNNLE1BQU1JLGtDQUFrQ3pCLGlEQUFnQjtJQUMzRHNDLFlBQVksRUFBRTlCLEtBQUssRUFBRSxDQUFFO1FBQ25CLEtBQUssQ0FBQyxVQUFpQixPQUFOQSxPQUFNO1FBQ3ZCK0IsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxRQUFRO1lBQ2hDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWbkMsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1ZhbHVlLmpzPzAxZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbi8qKiBAc2VlIGh0dHBzOi8vZXRoZXJldW0uZ2l0aHViLmlvL3llbGxvd3BhcGVyL3BhcGVyLnBkZiAqL1xuZXhwb3J0IGNvbnN0IGV4cG9uZW50cyA9IHtcbiAgICB3ZWk6IDAsXG4gICAgZ3dlaTogOSxcbiAgICBzemFibzogMTIsXG4gICAgZmlubmV5OiAxNSxcbiAgICBldGhlcjogMTgsXG59O1xuLyoqXG4gKiBGb3JtYXRzIGEgYGJpZ2ludGAgVmFsdWUgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbiAoZGl2aWRlZCBieSB0aGUgZ2l2ZW4gZXhwb25lbnQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mb3JtYXQoNDIwXzAwMF8wMDBfMDAwbiwgOSlcbiAqIC8vIEBsb2c6ICc0MjAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgVmFsdWUgdG8gZm9ybWF0LlxuICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIGV4cG9uZW50IHRvIGRpdmlkZSB0aGUgYGJpZ2ludGAgVmFsdWUgYnkuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgZGVjaW1hbHMgPSAwKSB7XG4gICAgbGV0IGRpc3BsYXkgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gZGlzcGxheS5zdGFydHNXaXRoKCctJyk7XG4gICAgaWYgKG5lZ2F0aXZlKVxuICAgICAgICBkaXNwbGF5ID0gZGlzcGxheS5zbGljZSgxKTtcbiAgICBkaXNwbGF5ID0gZGlzcGxheS5wYWRTdGFydChkZWNpbWFscywgJzAnKTtcbiAgICBsZXQgW2ludGVnZXIsIGZyYWN0aW9uXSA9IFtcbiAgICAgICAgZGlzcGxheS5zbGljZSgwLCBkaXNwbGF5Lmxlbmd0aCAtIGRlY2ltYWxzKSxcbiAgICAgICAgZGlzcGxheS5zbGljZShkaXNwbGF5Lmxlbmd0aCAtIGRlY2ltYWxzKSxcbiAgICBdO1xuICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ucmVwbGFjZSgvKDArKSQvLCAnJyk7XG4gICAgcmV0dXJuIGAke25lZ2F0aXZlID8gJy0nIDogJyd9JHtpbnRlZ2VyIHx8ICcwJ30ke2ZyYWN0aW9uID8gYC4ke2ZyYWN0aW9ufWAgOiAnJ31gO1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgRXRoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZvcm1hdEV0aGVyKDFfMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDBuKVxuICogLy8gQGxvZzogJzEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd2VpIC0gVGhlIFZhbHVlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gZm9ybWF0IHRoZSBWYWx1ZSBpbi4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBUaGUgRXRoZXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh3ZWksIGV4cG9uZW50cy5ldGhlciAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIEZvcm1hdHMgYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKSB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBHd2VpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mb3JtYXRHd2VpKDFfMDAwXzAwMF8wMDBuKVxuICogLy8gQGxvZzogJzEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd2VpIC0gVGhlIFZhbHVlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gZm9ybWF0IHRoZSBWYWx1ZSBpbi4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBUaGUgR3dlaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0R3dlaSh3ZWksIHVuaXQgPSAnd2VpJykge1xuICAgIHJldHVybiBmb3JtYXQod2VpLCBleHBvbmVudHMuZ3dlaSAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIFBhcnNlcyBhIGBzdHJpbmdgIHJlcHJlc2VudGF0aW9uIG9mIGEgVmFsdWUgdG8gYGJpZ2ludGAgKG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIGV4cG9uZW50KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbSgnNDIwJywgOSlcbiAqIC8vIEBsb2c6IDQyMDAwMDAwMDAwMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIGV4cG9uZW50IHRvIG11bHRpcGx5IHRoZSBWYWx1ZSBieS5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBkZWNpbWFscyA9IDApIHtcbiAgICBpZiAoIS9eKC0/KShbMC05XSopXFwuPyhbMC05XSopJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkRGVjaW1hbE51bWJlckVycm9yKHsgdmFsdWUgfSk7XG4gICAgbGV0IFtpbnRlZ2VyID0gJycsIGZyYWN0aW9uID0gJzAnXSA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgbmVnYXRpdmUgPSBpbnRlZ2VyLnN0YXJ0c1dpdGgoJy0nKTtcbiAgICBpZiAobmVnYXRpdmUpXG4gICAgICAgIGludGVnZXIgPSBpbnRlZ2VyLnNsaWNlKDEpO1xuICAgIC8vIHRyaW0gdHJhaWxpbmcgemVyb3MuXG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5yZXBsYWNlKC8oMCspJC8sICcnKTtcbiAgICAvLyByb3VuZCBvZmYgaWYgdGhlIGZyYWN0aW9uIGlzIGxhcmdlciB0aGFuIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMuXG4gICAgaWYgKGRlY2ltYWxzID09PSAwKSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKE51bWJlcihgLiR7ZnJhY3Rpb259YCkpID09PSAxKVxuICAgICAgICAgICAgaW50ZWdlciA9IGAke0JpZ0ludChpbnRlZ2VyKSArIDFufWA7XG4gICAgICAgIGZyYWN0aW9uID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbnN0IFtsZWZ0LCB1bml0LCByaWdodF0gPSBbXG4gICAgICAgICAgICBmcmFjdGlvbi5zbGljZSgwLCBkZWNpbWFscyAtIDEpLFxuICAgICAgICAgICAgZnJhY3Rpb24uc2xpY2UoZGVjaW1hbHMgLSAxLCBkZWNpbWFscyksXG4gICAgICAgICAgICBmcmFjdGlvbi5zbGljZShkZWNpbWFscyksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKE51bWJlcihgJHt1bml0fS4ke3JpZ2h0fWApKTtcbiAgICAgICAgaWYgKHJvdW5kZWQgPiA5KVxuICAgICAgICAgICAgZnJhY3Rpb24gPSBgJHtCaWdJbnQobGVmdCkgKyBCaWdJbnQoMSl9MGAucGFkU3RhcnQobGVmdC5sZW5ndGggKyAxLCAnMCcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmcmFjdGlvbiA9IGAke2xlZnR9JHtyb3VuZGVkfWA7XG4gICAgICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBkZWNpbWFscykge1xuICAgICAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zbGljZSgxKTtcbiAgICAgICAgICAgIGludGVnZXIgPSBgJHtCaWdJbnQoaW50ZWdlcikgKyAxbn1gO1xuICAgICAgICB9XG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc2xpY2UoMCwgZGVjaW1hbHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5wYWRFbmQoZGVjaW1hbHMsICcwJyk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYCR7bmVnYXRpdmUgPyAnLScgOiAnJ30ke2ludGVnZXJ9JHtmcmFjdGlvbn1gKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEV0aGVyIHRvIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZyb21FdGhlcignNDIwJylcbiAqIC8vIEBsb2c6IDQyMDAwMDAwMDAwMDAwMDAwMDAwMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBldGhlciAtIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBFdGhlci5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gcGFyc2UgdG8uIEBkZWZhdWx0ICd3ZWknLlxuICogQHJldHVybnMgQSBgYmlnaW50YCBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdGhlcihldGhlciwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZyb20oZXRoZXIsIGV4cG9uZW50cy5ldGhlciAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBHd2VpIHRvIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZyb21Hd2VpKCc0MjAnKVxuICogLy8gQGxvZzogNDIwMDAwMDAwMDAwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGd3ZWkgLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgR3dlaS5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gcGFyc2UgdG8uIEBkZWZhdWx0ICd3ZWknLlxuICogQHJldHVybnMgQSBgYmlnaW50YCBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Hd2VpKGd3ZWksIHVuaXQgPSAnd2VpJykge1xuICAgIHJldHVybiBmcm9tKGd3ZWksIGV4cG9uZW50cy5nd2VpIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbUV0aGVyKCcxMjMuNDU2Ljc4OScpXG4gKiAvLyBAZXJyb3I6IFZhbHVlLkludmFsaWREZWNpbWFsTnVtYmVyRXJyb3I6IFZhbHVlIGAxMjMuNDU2Ljc4OWAgaXMgbm90IGEgdmFsaWQgZGVjaW1hbCBudW1iZXIuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREZWNpbWFsTnVtYmVyRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBhIHZhbGlkIGRlY2ltYWwgbnVtYmVyLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVmFsdWUuSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsdWUuanMubWFwIl0sIm5hbWVzIjpbIkVycm9ycyIsImV4cG9uZW50cyIsIndlaSIsImd3ZWkiLCJzemFibyIsImZpbm5leSIsImV0aGVyIiwiZm9ybWF0IiwidmFsdWUiLCJkZWNpbWFscyIsImRpc3BsYXkiLCJ0b1N0cmluZyIsIm5lZ2F0aXZlIiwic3RhcnRzV2l0aCIsInNsaWNlIiwicGFkU3RhcnQiLCJpbnRlZ2VyIiwiZnJhY3Rpb24iLCJsZW5ndGgiLCJyZXBsYWNlIiwiZm9ybWF0RXRoZXIiLCJ1bml0IiwiZm9ybWF0R3dlaSIsImZyb20iLCJ0ZXN0IiwiSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvciIsInNwbGl0IiwiTWF0aCIsInJvdW5kIiwiTnVtYmVyIiwiQmlnSW50IiwibGVmdCIsInJpZ2h0Iiwicm91bmRlZCIsInBhZEVuZCIsImZyb21FdGhlciIsImZyb21Hd2VpIiwiQmFzZUVycm9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js":
/*!***************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   estimateL1Fee: function() { return /* binding */ estimateL1Fee; }\n/* harmony export */ });\n/* harmony import */ var _contract_contract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../contract/contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/contract/contract.js\");\n/* harmony import */ var _transaction_actions_to_serializable_transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transaction/actions/to-serializable-transaction.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/actions/to-serializable-transaction.js\");\n/* harmony import */ var _transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/read-contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/read-contract.js\");\n/* harmony import */ var _transaction_serialize_transaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/serialize-transaction.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js\");\n\n\n\n\nconst OPStackGasPriceOracleAddress = \"0x420000000000000000000000000000000000000F\";\n/**\n * @internal\n */ async function estimateL1Fee(options) {\n    const { transaction, gasPriceOracleAddress } = options;\n    const oracleContract = (0,_contract_contract_js__WEBPACK_IMPORTED_MODULE_0__.getContract)({\n        client: transaction.client,\n        address: gasPriceOracleAddress || OPStackGasPriceOracleAddress,\n        chain: transaction.chain\n    });\n    // purposefully remove gasPrice from the transaction\n    const { gasPrice, ...serializableTx } = await (0,_transaction_actions_to_serializable_transaction_js__WEBPACK_IMPORTED_MODULE_1__.toSerializableTransaction)({\n        transaction\n    });\n    const serialized = (0,_transaction_serialize_transaction_js__WEBPACK_IMPORTED_MODULE_2__.serializeTransaction)({\n        transaction: serializableTx\n    });\n    //serializeTransaction(transaction);\n    return (0,_transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_3__.readContract)({\n        contract: oracleContract,\n        method: \"function getL1Fee(bytes memory _data) view returns (uint256)\",\n        params: [\n            serialized\n        ]\n    });\n} //# sourceMappingURL=estimate-l1-fee.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9nYXMvZXN0aW1hdGUtbDEtZmVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQzRDO0FBQ25DO0FBQ2dCO0FBQy9FLE1BQU1JLCtCQUErQjtBQUNyQzs7Q0FFQyxHQUNNLGVBQWVDLGNBQWNDLE9BQU87SUFDdkMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLHFCQUFxQixFQUFFLEdBQUdGO0lBQy9DLE1BQU1HLGlCQUFpQlQsa0VBQVdBLENBQUM7UUFDL0JVLFFBQVFILFlBQVlHLE1BQU07UUFDMUJDLFNBQVNILHlCQUF5Qko7UUFDbENRLE9BQU9MLFlBQVlLLEtBQUs7SUFDNUI7SUFDQSxvREFBb0Q7SUFDcEQsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0MsZ0JBQWdCLEdBQUcsTUFBTWIsOEdBQXlCQSxDQUFDO1FBQ3BFTTtJQUNKO0lBQ0EsTUFBTVEsYUFBYVosMkZBQW9CQSxDQUFDO1FBQ3BDSSxhQUFhTztJQUNqQjtJQUNBLG9DQUFvQztJQUNwQyxPQUFPWiwyRUFBWUEsQ0FBQztRQUNoQmMsVUFBVVA7UUFDVlEsUUFBUTtRQUNSQyxRQUFRO1lBQUNIO1NBQVc7SUFDeEI7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vZ2FzL2VzdGltYXRlLWwxLWZlZS5qcz83NjA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldENvbnRyYWN0IH0gZnJvbSBcIi4uL2NvbnRyYWN0L2NvbnRyYWN0LmpzXCI7XG5pbXBvcnQgeyB0b1NlcmlhbGl6YWJsZVRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL2FjdGlvbnMvdG8tc2VyaWFsaXphYmxlLXRyYW5zYWN0aW9uLmpzXCI7XG5pbXBvcnQgeyByZWFkQ29udHJhY3QgfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vcmVhZC1jb250cmFjdC5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplVHJhbnNhY3Rpb24gfSBmcm9tIFwiLi4vdHJhbnNhY3Rpb24vc2VyaWFsaXplLXRyYW5zYWN0aW9uLmpzXCI7XG5jb25zdCBPUFN0YWNrR2FzUHJpY2VPcmFjbGVBZGRyZXNzID0gXCIweDQyMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMEZcIjtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlc3RpbWF0ZUwxRmVlKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9uLCBnYXNQcmljZU9yYWNsZUFkZHJlc3MgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb3JhY2xlQ29udHJhY3QgPSBnZXRDb250cmFjdCh7XG4gICAgICAgIGNsaWVudDogdHJhbnNhY3Rpb24uY2xpZW50LFxuICAgICAgICBhZGRyZXNzOiBnYXNQcmljZU9yYWNsZUFkZHJlc3MgfHwgT1BTdGFja0dhc1ByaWNlT3JhY2xlQWRkcmVzcyxcbiAgICAgICAgY2hhaW46IHRyYW5zYWN0aW9uLmNoYWluLFxuICAgIH0pO1xuICAgIC8vIHB1cnBvc2VmdWxseSByZW1vdmUgZ2FzUHJpY2UgZnJvbSB0aGUgdHJhbnNhY3Rpb25cbiAgICBjb25zdCB7IGdhc1ByaWNlLCAuLi5zZXJpYWxpemFibGVUeCB9ID0gYXdhaXQgdG9TZXJpYWxpemFibGVUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgIH0pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVUcmFuc2FjdGlvbih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBzZXJpYWxpemFibGVUeCxcbiAgICB9KTtcbiAgICAvL3NlcmlhbGl6ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gcmVhZENvbnRyYWN0KHtcbiAgICAgICAgY29udHJhY3Q6IG9yYWNsZUNvbnRyYWN0LFxuICAgICAgICBtZXRob2Q6IFwiZnVuY3Rpb24gZ2V0TDFGZWUoYnl0ZXMgbWVtb3J5IF9kYXRhKSB2aWV3IHJldHVybnMgKHVpbnQyNTYpXCIsXG4gICAgICAgIHBhcmFtczogW3NlcmlhbGl6ZWRdLFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXN0aW1hdGUtbDEtZmVlLmpzLm1hcCJdLCJuYW1lcyI6WyJnZXRDb250cmFjdCIsInRvU2VyaWFsaXphYmxlVHJhbnNhY3Rpb24iLCJyZWFkQ29udHJhY3QiLCJzZXJpYWxpemVUcmFuc2FjdGlvbiIsIk9QU3RhY2tHYXNQcmljZU9yYWNsZUFkZHJlc3MiLCJlc3RpbWF0ZUwxRmVlIiwib3B0aW9ucyIsInRyYW5zYWN0aW9uIiwiZ2FzUHJpY2VPcmFjbGVBZGRyZXNzIiwib3JhY2xlQ29udHJhY3QiLCJjbGllbnQiLCJhZGRyZXNzIiwiY2hhaW4iLCJnYXNQcmljZSIsInNlcmlhbGl6YWJsZVR4Iiwic2VyaWFsaXplZCIsImNvbnRyYWN0IiwibWV0aG9kIiwicGFyYW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serializeTransaction: function() { return /* binding */ serializeTransaction; }\n/* harmony export */ });\n/* harmony import */ var ox_Hex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ox/Hex */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var ox_Signature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ox/Signature */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ox/TransactionEnvelopeEip1559 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ox/TransactionEnvelopeEip2930 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ox/TransactionEnvelopeEip7702 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js\");\n/* harmony import */ var ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ox/TransactionEnvelopeLegacy */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js\");\n\n\n\n\n\n\n/**\n * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.\n *\n * @param options - The serialization options.\n * @param options.transaction - The transaction object to be serialized.\n * @param [options.signature] - The signature to include with the transaction, if necessary.\n * @returns The serialized transaction.\n * @throws An error if the provided transaction object is invalid.\n * @transaction\n * @example\n * ```ts\n * import { serializeTransaction } from \"thirdweb\";\n *\n * const serializedTransaction = serializeTransaction({ transaction: {\n *    to: \"0x\",\n *    value: 0n,\n *  }\n * });\n * ```\n */ function serializeTransaction(options) {\n    const { transaction } = options;\n    const type = getTransactionEnvelopeType(transaction);\n    // This is to maintain compatibility with our old interface (including the signature in the transaction object)\n    const signature = (()=>{\n        if (options.signature) {\n            if (\"v\" in options.signature && typeof options.signature.v !== \"undefined\") {\n                return ox_Signature__WEBPACK_IMPORTED_MODULE_0__.fromLegacy({\n                    r: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.r),\n                    s: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.s),\n                    v: Number(options.signature.v)\n                });\n            }\n            return {\n                r: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.r),\n                s: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.s),\n                // We force the Signature type here because we filter for legacy type above\n                yParity: options.signature.yParity\n            };\n        }\n        if (typeof transaction.v === \"undefined\" && typeof transaction.yParity === \"undefined\") {\n            return undefined;\n        }\n        if (transaction.r === undefined || transaction.s === undefined) {\n            throw new Error(\"Invalid signature provided with transaction\");\n        }\n        return {\n            r: typeof transaction.r === \"bigint\" ? transaction.r : ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(transaction.r),\n            s: typeof transaction.s === \"bigint\" ? transaction.s : ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(transaction.s),\n            yParity: typeof transaction.v !== \"undefined\" && typeof transaction.yParity === \"undefined\" ? ox_Signature__WEBPACK_IMPORTED_MODULE_0__.vToYParity(Number(transaction.v)) : Number(transaction.yParity)\n        };\n    })();\n    if (type === \"eip1559\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__.serialize(typedTransaction, {\n            signature\n        });\n    }\n    if (type === \"legacy\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__.assert(typedTransaction);\n        return ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__.serialize(typedTransaction, {\n            signature\n        });\n    }\n    if (type === \"eip2930\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__.serialize(typedTransaction, {\n            signature\n        });\n    }\n    if (type === \"eip7702\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__.serialize(typedTransaction, {\n            signature\n        });\n    }\n    throw new Error(\"Invalid transaction type\");\n}\n/**\n * @internal\n */ function getTransactionEnvelopeType(transactionEnvelope) {\n    if (typeof transactionEnvelope.type !== \"undefined\") {\n        return transactionEnvelope.type;\n    }\n    if (typeof transactionEnvelope.authorizationList !== \"undefined\") {\n        return \"eip7702\";\n    }\n    if (typeof transactionEnvelope.maxFeePerGas !== \"undefined\" || typeof transactionEnvelope.maxPriorityFeePerGas !== \"undefined\") {\n        return \"eip1559\";\n    }\n    if (typeof transactionEnvelope.gasPrice !== \"undefined\") {\n        if (typeof transactionEnvelope.accessList !== \"undefined\") {\n            return \"eip2930\";\n        }\n        return \"legacy\";\n    }\n    throw new Error(\"Invalid transaction type\");\n} //# sourceMappingURL=serialize-transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS90cmFuc2FjdGlvbi9zZXJpYWxpemUtdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrQztBQUNZO0FBQ2tDO0FBQ0E7QUFDQTtBQUNGO0FBQzlFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ00sU0FBU00scUJBQXFCQyxPQUFPO0lBQ3hDLE1BQU0sRUFBRUMsV0FBVyxFQUFFLEdBQUdEO0lBQ3hCLE1BQU1FLE9BQU9DLDJCQUEyQkY7SUFDeEMsK0dBQStHO0lBQy9HLE1BQU1HLFlBQVksQ0FBQztRQUNmLElBQUlKLFFBQVFJLFNBQVMsRUFBRTtZQUNuQixJQUFJLE9BQU9KLFFBQVFJLFNBQVMsSUFDeEIsT0FBT0osUUFBUUksU0FBUyxDQUFDQyxDQUFDLEtBQUssYUFBYTtnQkFDNUMsT0FBT1gsb0RBQXdCLENBQUM7b0JBQzVCYSxHQUFHZCw0Q0FBZ0IsQ0FBQ08sUUFBUUksU0FBUyxDQUFDRyxDQUFDO29CQUN2Q0UsR0FBR2hCLDRDQUFnQixDQUFDTyxRQUFRSSxTQUFTLENBQUNLLENBQUM7b0JBQ3ZDSixHQUFHSyxPQUFPVixRQUFRSSxTQUFTLENBQUNDLENBQUM7Z0JBQ2pDO1lBQ0o7WUFDQSxPQUFPO2dCQUNIRSxHQUFHZCw0Q0FBZ0IsQ0FBQ08sUUFBUUksU0FBUyxDQUFDRyxDQUFDO2dCQUN2Q0UsR0FBR2hCLDRDQUFnQixDQUFDTyxRQUFRSSxTQUFTLENBQUNLLENBQUM7Z0JBQ3ZDLDJFQUEyRTtnQkFDM0VFLFNBQVNYLFFBQVFJLFNBQVMsQ0FDckJPLE9BQU87WUFDaEI7UUFDSjtRQUNBLElBQUksT0FBT1YsWUFBWUksQ0FBQyxLQUFLLGVBQ3pCLE9BQU9KLFlBQVlVLE9BQU8sS0FBSyxhQUFhO1lBQzVDLE9BQU9DO1FBQ1g7UUFDQSxJQUFJWCxZQUFZTSxDQUFDLEtBQUtLLGFBQWFYLFlBQVlRLENBQUMsS0FBS0csV0FBVztZQUM1RCxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxPQUFPO1lBQ0hOLEdBQUcsT0FBT04sWUFBWU0sQ0FBQyxLQUFLLFdBQ3RCTixZQUFZTSxDQUFDLEdBQ2JkLDRDQUFnQixDQUFDUSxZQUFZTSxDQUFDO1lBQ3BDRSxHQUFHLE9BQU9SLFlBQVlRLENBQUMsS0FBSyxXQUN0QlIsWUFBWVEsQ0FBQyxHQUNiaEIsNENBQWdCLENBQUNRLFlBQVlRLENBQUM7WUFDcENFLFNBQVMsT0FBT1YsWUFBWUksQ0FBQyxLQUFLLGVBQzlCLE9BQU9KLFlBQVlVLE9BQU8sS0FBSyxjQUM3QmpCLG9EQUF3QixDQUFDZ0IsT0FBT1QsWUFBWUksQ0FBQyxLQUM3Q0ssT0FBT1QsWUFBWVUsT0FBTztRQUNwQztJQUNKO0lBQ0EsSUFBSVQsU0FBUyxXQUFXO1FBQ3BCLE1BQU1hLG1CQUFtQmQ7UUFDekJOLGlFQUFxQyxDQUFDb0I7UUFDdEMsT0FBT3BCLG9FQUF3QyxDQUFDb0Isa0JBQWtCO1lBQzlEWDtRQUNKO0lBQ0o7SUFDQSxJQUFJRixTQUFTLFVBQVU7UUFDbkIsTUFBTWEsbUJBQW1CZDtRQUN6QkgsZ0VBQW9DLENBQUNpQjtRQUNyQyxPQUFPakIsbUVBQXVDLENBQUNpQixrQkFBa0I7WUFDN0RYO1FBQ0o7SUFDSjtJQUNBLElBQUlGLFNBQVMsV0FBVztRQUNwQixNQUFNYSxtQkFBbUJkO1FBQ3pCTCxpRUFBcUMsQ0FBQ21CO1FBQ3RDLE9BQU9uQixvRUFBd0MsQ0FBQ21CLGtCQUFrQjtZQUM5RFg7UUFDSjtJQUNKO0lBQ0EsSUFBSUYsU0FBUyxXQUFXO1FBQ3BCLE1BQU1hLG1CQUFtQmQ7UUFDekJKLGlFQUFxQyxDQUFDa0I7UUFDdEMsT0FBT2xCLG9FQUF3QyxDQUFDa0Isa0JBQWtCO1lBQzlEWDtRQUNKO0lBQ0o7SUFDQSxNQUFNLElBQUlTLE1BQU07QUFDcEI7QUFDQTs7Q0FFQyxHQUNELFNBQVNWLDJCQUEyQmUsbUJBQW1CO0lBQ25ELElBQUksT0FBT0Esb0JBQW9CaEIsSUFBSSxLQUFLLGFBQWE7UUFDakQsT0FBT2dCLG9CQUFvQmhCLElBQUk7SUFDbkM7SUFDQSxJQUFJLE9BQU9nQixvQkFBb0JDLGlCQUFpQixLQUFLLGFBQWE7UUFDOUQsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFPRCxvQkFBb0JFLFlBQVksS0FBSyxlQUM1QyxPQUFPRixvQkFBb0JHLG9CQUFvQixLQUFLLGFBQWE7UUFDakUsT0FBTztJQUNYO0lBQ0EsSUFBSSxPQUFPSCxvQkFBb0JJLFFBQVEsS0FBSyxhQUFhO1FBQ3JELElBQUksT0FBT0osb0JBQW9CSyxVQUFVLEtBQUssYUFBYTtZQUN2RCxPQUFPO1FBQ1g7UUFDQSxPQUFPO0lBQ1g7SUFDQSxNQUFNLElBQUlWLE1BQU07QUFDcEIsRUFDQSxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3RyYW5zYWN0aW9uL3NlcmlhbGl6ZS10cmFuc2FjdGlvbi5qcz83NDc5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG94X19IZXggZnJvbSBcIm94L0hleFwiO1xuaW1wb3J0ICogYXMgb3hfX1NpZ25hdHVyZSBmcm9tIFwib3gvU2lnbmF0dXJlXCI7XG5pbXBvcnQgKiBhcyBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgZnJvbSBcIm94L1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5XCI7XG5pbXBvcnQgKiBhcyBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgZnJvbSBcIm94L1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwXCI7XG5pbXBvcnQgKiBhcyBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIgZnJvbSBcIm94L1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyXCI7XG5pbXBvcnQgKiBhcyBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSBmcm9tIFwib3gvVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeVwiO1xuLyoqXG4gKiBTZXJpYWxpemVzIGEgbGVnYWN5LCBFSVAtMTU1OSwgRUlQLTI5MzAsIEVJUC00ODQ0LCBvciBFSVAtNzcwMiB0cmFuc2FjdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2VyaWFsaXphdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMudHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGJlIHNlcmlhbGl6ZWQuXG4gKiBAcGFyYW0gW29wdGlvbnMuc2lnbmF0dXJlXSAtIFRoZSBzaWduYXR1cmUgdG8gaW5jbHVkZSB3aXRoIHRoZSB0cmFuc2FjdGlvbiwgaWYgbmVjZXNzYXJ5LlxuICogQHJldHVybnMgVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBwcm92aWRlZCB0cmFuc2FjdGlvbiBvYmplY3QgaXMgaW52YWxpZC5cbiAqIEB0cmFuc2FjdGlvblxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzZXJpYWxpemVUcmFuc2FjdGlvbiB9IGZyb20gXCJ0aGlyZHdlYlwiO1xuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHNlcmlhbGl6ZVRyYW5zYWN0aW9uKHsgdHJhbnNhY3Rpb246IHtcbiAqICAgIHRvOiBcIjB4XCIsXG4gKiAgICB2YWx1ZTogMG4sXG4gKiAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVRyYW5zYWN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9uIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRUcmFuc2FjdGlvbkVudmVsb3BlVHlwZSh0cmFuc2FjdGlvbik7XG4gICAgLy8gVGhpcyBpcyB0byBtYWludGFpbiBjb21wYXRpYmlsaXR5IHdpdGggb3VyIG9sZCBpbnRlcmZhY2UgKGluY2x1ZGluZyB0aGUgc2lnbmF0dXJlIGluIHRoZSB0cmFuc2FjdGlvbiBvYmplY3QpXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICBpZiAoXCJ2XCIgaW4gb3B0aW9ucy5zaWduYXR1cmUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zaWduYXR1cmUudiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBveF9fU2lnbmF0dXJlLmZyb21MZWdhY3koe1xuICAgICAgICAgICAgICAgICAgICByOiBveF9fSGV4LnRvQmlnSW50KG9wdGlvbnMuc2lnbmF0dXJlLnIpLFxuICAgICAgICAgICAgICAgICAgICBzOiBveF9fSGV4LnRvQmlnSW50KG9wdGlvbnMuc2lnbmF0dXJlLnMpLFxuICAgICAgICAgICAgICAgICAgICB2OiBOdW1iZXIob3B0aW9ucy5zaWduYXR1cmUudiksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IG94X19IZXgudG9CaWdJbnQob3B0aW9ucy5zaWduYXR1cmUuciksXG4gICAgICAgICAgICAgICAgczogb3hfX0hleC50b0JpZ0ludChvcHRpb25zLnNpZ25hdHVyZS5zKSxcbiAgICAgICAgICAgICAgICAvLyBXZSBmb3JjZSB0aGUgU2lnbmF0dXJlIHR5cGUgaGVyZSBiZWNhdXNlIHdlIGZpbHRlciBmb3IgbGVnYWN5IHR5cGUgYWJvdmVcbiAgICAgICAgICAgICAgICB5UGFyaXR5OiBvcHRpb25zLnNpZ25hdHVyZVxuICAgICAgICAgICAgICAgICAgICAueVBhcml0eSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi52ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgdHJhbnNhY3Rpb24ueVBhcml0eSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uciA9PT0gdW5kZWZpbmVkIHx8IHRyYW5zYWN0aW9uLnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduYXR1cmUgcHJvdmlkZWQgd2l0aCB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogdHlwZW9mIHRyYW5zYWN0aW9uLnIgPT09IFwiYmlnaW50XCJcbiAgICAgICAgICAgICAgICA/IHRyYW5zYWN0aW9uLnJcbiAgICAgICAgICAgICAgICA6IG94X19IZXgudG9CaWdJbnQodHJhbnNhY3Rpb24uciksXG4gICAgICAgICAgICBzOiB0eXBlb2YgdHJhbnNhY3Rpb24ucyA9PT0gXCJiaWdpbnRcIlxuICAgICAgICAgICAgICAgID8gdHJhbnNhY3Rpb24uc1xuICAgICAgICAgICAgICAgIDogb3hfX0hleC50b0JpZ0ludCh0cmFuc2FjdGlvbi5zKSxcbiAgICAgICAgICAgIHlQYXJpdHk6IHR5cGVvZiB0cmFuc2FjdGlvbi52ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRyYW5zYWN0aW9uLnlQYXJpdHkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IG94X19TaWduYXR1cmUudlRvWVBhcml0eShOdW1iZXIodHJhbnNhY3Rpb24udikpXG4gICAgICAgICAgICAgICAgOiBOdW1iZXIodHJhbnNhY3Rpb24ueVBhcml0eSksXG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJlaXAxNTU5XCIpIHtcbiAgICAgICAgY29uc3QgdHlwZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KHR5cGVkVHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnNlcmlhbGl6ZSh0eXBlZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJsZWdhY3lcIikge1xuICAgICAgICBjb25zdCB0eXBlZFRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIG94X19UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmFzc2VydCh0eXBlZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG94X19UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LnNlcmlhbGl6ZSh0eXBlZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJlaXAyOTMwXCIpIHtcbiAgICAgICAgY29uc3QgdHlwZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuYXNzZXJ0KHR5cGVkVHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnNlcmlhbGl6ZSh0eXBlZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJlaXA3NzAyXCIpIHtcbiAgICAgICAgY29uc3QgdHlwZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuYXNzZXJ0KHR5cGVkVHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLnNlcmlhbGl6ZSh0eXBlZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRyYW5zYWN0aW9uIHR5cGVcIik7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkVudmVsb3BlVHlwZSh0cmFuc2FjdGlvbkVudmVsb3BlKSB7XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVudmVsb3BlLnR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRW52ZWxvcGUudHlwZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVudmVsb3BlLmF1dGhvcml6YXRpb25MaXN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBcImVpcDc3MDJcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVudmVsb3BlLm1heEZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICB0eXBlb2YgdHJhbnNhY3Rpb25FbnZlbG9wZS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gXCJlaXAxNTU5XCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25FbnZlbG9wZS5nYXNQcmljZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uRW52ZWxvcGUuYWNjZXNzTGlzdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiZWlwMjkzMFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcImxlZ2FjeVwiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRyYW5zYWN0aW9uIHR5cGVcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWxpemUtdHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbIm94X19IZXgiLCJveF9fU2lnbmF0dXJlIiwib3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5Iiwib3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwIiwib3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyIiwib3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kiLCJzZXJpYWxpemVUcmFuc2FjdGlvbiIsIm9wdGlvbnMiLCJ0cmFuc2FjdGlvbiIsInR5cGUiLCJnZXRUcmFuc2FjdGlvbkVudmVsb3BlVHlwZSIsInNpZ25hdHVyZSIsInYiLCJmcm9tTGVnYWN5IiwiciIsInRvQmlnSW50IiwicyIsIk51bWJlciIsInlQYXJpdHkiLCJ1bmRlZmluZWQiLCJFcnJvciIsInZUb1lQYXJpdHkiLCJ0eXBlZFRyYW5zYWN0aW9uIiwiYXNzZXJ0Iiwic2VyaWFsaXplIiwidHJhbnNhY3Rpb25FbnZlbG9wZSIsImF1dGhvcml6YXRpb25MaXN0IiwibWF4RmVlUGVyR2FzIiwibWF4UHJpb3JpdHlGZWVQZXJHYXMiLCJnYXNQcmljZSIsImFjY2Vzc0xpc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js\n"));

/***/ })

}]);